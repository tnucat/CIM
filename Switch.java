package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for Switch
 * Generated by CIMTool http://cimtool.org
 */
public class Switch
{
    /**
     * A wire or combination of wires, with consistent electrical characteristics,
     * building a single electrical system, used to carry alternating current
     * between points in the power system.
     * For symmetrical, transposed three phase lines, it is sufficient to use
     * attributes of the line segment, which describe impedances and admittances
     * for the entire length of the segment. Additionally impedances can be computed
     * by using length and associated per length impedances.
     * The BaseVoltage at the two ends of ACLineSegments in a Line shall have
     * the same BaseVoltage.nominalVoltage. However, boundary lines may have slightly
     * different BaseVoltage.nominalVoltages and variation is allowed. Larger
     * voltage difference in general requires use of an equivalent branch.
     */
    @Entity
    @Table(name="\"ACLineSegment\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class ACLineSegment extends Conductor
    {
        /**
         * Zero sequence shunt (charging) susceptance, uniformly distributed, of the
         * entire line section.
         */
        public Double getB0ch () { return b0ch; }
        public void setB0ch ( Double b0ch ) { this.b0ch = b0ch; }
        @Basic()
        @Column(name="\"b0ch\"")
        private Double b0ch ;
         
        /**
         * Positive sequence shunt (charging) susceptance, uniformly distributed,
         * of the entire line section. This value represents the full charging over
         * the full length of the line.
         */
        public Double getBch () { return bch; }
        public void setBch ( Double bch ) { this.bch = bch; }
        @Basic()
        @Column(name="\"bch\"")
        private Double bch ;
         
        /**
         * Zero sequence shunt (charging) conductance, uniformly distributed, of the
         * entire line section.
         */
        public Double getG0ch () { return g0ch; }
        public void setG0ch ( Double g0ch ) { this.g0ch = g0ch; }
        @Basic()
        @Column(name="\"g0ch\"")
        private Double g0ch ;
         
        /**
         * Positive sequence shunt (charging) conductance, uniformly distributed,
         * of the entire line section.
         */
        public Double getGch () { return gch; }
        public void setGch ( Double gch ) { this.gch = gch; }
        @Basic()
        @Column(name="\"gch\"")
        private Double gch ;
         
        /**
         * Positive sequence series resistance of the entire line section.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence series resistance of the entire line section.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Maximum permitted temperature at the end of SC for the calculation of minimum
         * short-circuit currents. Used for short circuit data exchange according
         * to IEC 60909.
         */
        public Double getShortCircuitEndTemperature () { return shortCircuitEndTemperature; }
        public void setShortCircuitEndTemperature ( Double shortCircuitEndTemperature ) { this.shortCircuitEndTemperature = shortCircuitEndTemperature; }
        @Basic()
        @Column(name="\"shortCircuitEndTemperature\"")
        private Double shortCircuitEndTemperature ;
         
        /**
         * Positive sequence series reactance of the entire line section.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero sequence series reactance of the entire line section.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * Ground action involving clamp usage (for the case when the ground is applied
         * along the line segment instead of at its terminals).
         */
        public GroundAction getLineGroundingAction () { return lineGroundingAction; }
        public void setLineGroundingAction ( GroundAction lineGroundingAction ) { this.lineGroundingAction = lineGroundingAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"LineGroundingAction\"")
        private GroundAction lineGroundingAction ;
         
        /**
         * Jumper action involving clamp usage (for the case when the jumper is applied
         * along the line segment instead of at its terminals).
         */
        public JumperAction getLineJumpingAction () { return lineJumpingAction; }
        public void setLineJumpingAction ( JumperAction lineJumpingAction ) { this.lineJumpingAction = lineJumpingAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"LineJumpingAction\"")
        private JumperAction lineJumpingAction ;
         
        /**
         * Per-length impedance of this line segment.
         */
        public PerLengthImpedance getPerLengthImpedance () { return perLengthImpedance; }
        public void setPerLengthImpedance ( PerLengthImpedance perLengthImpedance ) { this.perLengthImpedance = perLengthImpedance; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PerLengthImpedance\"")
        private PerLengthImpedance perLengthImpedance ;
         
        /**
         * The wire spacing information that applies to this AC line segment
         */
        public WireSpacingInfo getWireSpacingInfo () { return wireSpacingInfo; }
        public void setWireSpacingInfo ( WireSpacingInfo wireSpacingInfo ) { this.wireSpacingInfo = wireSpacingInfo; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"WireSpacingInfo\"")
        private WireSpacingInfo wireSpacingInfo ;
         
    }
    /**
     * Represents a single wire of an alternating current line segment.
     */
    @Entity
    @Table(name="\"ACLineSegmentPhase\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ACLineSegmentPhase
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The phase connection of the wire at both ends.
         */
        public String getPhase () { return phase; }
        public void setPhase ( String phase ) { this.phase = phase; }
        @Basic()
        @Column(name="\"phase\"")
        private String phase ;
         
        /**
         * Number designation for this line segment phase. Each line segment phase
         * within a line segment should have a unique sequence number. This is useful
         * for unbalanced modelling to bind the mathematical model (PhaseImpedanceData
         * of PerLengthPhaseImpedance) with the connectivity model (this class) and
         * the physical model (WirePosition) without tight coupling.
         */
        public Integer getSequenceNumber () { return sequenceNumber; }
        public void setSequenceNumber ( Integer sequenceNumber ) { this.sequenceNumber = sequenceNumber; }
        @Basic()
        @Column(name="\"sequenceNumber\"")
        private Integer sequenceNumber ;
         
        /**
         * The line segment to which the phase belongs.
         */
        public ACLineSegment getACLineSegment () { return aCLineSegment; }
        public void setACLineSegment ( ACLineSegment aCLineSegment ) { this.aCLineSegment = aCLineSegment; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ACLineSegment\"")
        private ACLineSegment aCLineSegment ;
         
        /**
         * Wire information contributing to this AC line segment phase information.
         */
        public WireInfo getWireInfo () { return wireInfo; }
        public void setWireInfo ( WireInfo wireInfo ) { this.wireInfo = wireInfo; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"WireInfo\"")
        private WireInfo wireInfo ;
         
    }
    /**
     * A rotating machine whose shaft rotates asynchronously with the electrical
     * field. Also known as an induction machine with no external connection to
     * the rotor windings, e.g. squirrel-cage induction machine.
     */
    @Entity
    @Table(name="\"AsynchronousMachine\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class AsynchronousMachine extends RotatingMachine
    {
        /**
         * Indicates the type of Asynchronous Machine (motor or generator).
         */
        public String getAsynchronousMachineType () { return asynchronousMachineType; }
        public void setAsynchronousMachineType ( String asynchronousMachineType ) { this.asynchronousMachineType = asynchronousMachineType; }
        @Basic()
        @Column(name="\"asynchronousMachineType\"")
        private String asynchronousMachineType ;
         
        /**
         * Indicates whether the machine is a converter fed drive. Used for short
         * circuit data exchange according to IEC 60909.
         */
        public Boolean getConverterFedDrive () { return converterFedDrive; }
        public void setConverterFedDrive ( Boolean converterFedDrive ) { this.converterFedDrive = converterFedDrive; }
        @Basic()
        @Column(name="\"converterFedDrive\"")
        private Boolean converterFedDrive ;
         
        /**
         * Efficiency of the asynchronous machine at nominal operation as a percentage.
         * Indicator for converter drive motors. Used for short circuit data exchange
         * according to IEC 60909.
         */
        public Double getEfficiency () { return efficiency; }
        public void setEfficiency ( Double efficiency ) { this.efficiency = efficiency; }
        @Basic()
        @Column(name="\"efficiency\"")
        private Double efficiency ;
         
        /**
         * Ratio of locked-rotor current to the rated current of the motor (Ia/Ir).
         * Used for short circuit data exchange according to IEC 60909.
         */
        public Double getIaIrRatio () { return iaIrRatio; }
        public void setIaIrRatio ( Double iaIrRatio ) { this.iaIrRatio = iaIrRatio; }
        @Basic()
        @Column(name="\"iaIrRatio\"")
        private Double iaIrRatio ;
         
        /**
         * Nameplate data indicates if the machine is 50 Hz or 60 Hz.
         */
        public Double getNominalFrequency () { return nominalFrequency; }
        public void setNominalFrequency ( Double nominalFrequency ) { this.nominalFrequency = nominalFrequency; }
        @Basic()
        @Column(name="\"nominalFrequency\"")
        private Double nominalFrequency ;
         
        /**
         * Nameplate data. Depends on the slip and number of pole pairs.
         */
        public Double getNominalSpeed () { return nominalSpeed; }
        public void setNominalSpeed ( Double nominalSpeed ) { this.nominalSpeed = nominalSpeed; }
        @Basic()
        @Column(name="\"nominalSpeed\"")
        private Double nominalSpeed ;
         
        /**
         * Number of pole pairs of stator. Used for short circuit data exchange according
         * to IEC 60909.
         */
        public Integer getPolePairNumber () { return polePairNumber; }
        public void setPolePairNumber ( Integer polePairNumber ) { this.polePairNumber = polePairNumber; }
        @Basic()
        @Column(name="\"polePairNumber\"")
        private Integer polePairNumber ;
         
        /**
         * Rated mechanical power (Pr in IEC 60909-0). Used for short circuit data
         * exchange according to IEC 60909.
         */
        public Double getRatedMechanicalPower () { return ratedMechanicalPower; }
        public void setRatedMechanicalPower ( Double ratedMechanicalPower ) { this.ratedMechanicalPower = ratedMechanicalPower; }
        @Basic()
        @Column(name="\"ratedMechanicalPower\"")
        private Double ratedMechanicalPower ;
         
        /**
         * Indicates for converter drive motors if the power can be reversible. Used
         * for short circuit data exchange according to IEC 60909.
         */
        public Boolean getReversible () { return reversible; }
        public void setReversible ( Boolean reversible ) { this.reversible = reversible; }
        @Basic()
        @Column(name="\"reversible\"")
        private Boolean reversible ;
         
        /**
         * Damper 1 winding resistance.
         */
        public Double getRr1 () { return rr1; }
        public void setRr1 ( Double rr1 ) { this.rr1 = rr1; }
        @Basic()
        @Column(name="\"rr1\"")
        private Double rr1 ;
         
        /**
         * Damper 2 winding resistance.
         */
        public Double getRr2 () { return rr2; }
        public void setRr2 ( Double rr2 ) { this.rr2 = rr2; }
        @Basic()
        @Column(name="\"rr2\"")
        private Double rr2 ;
         
        /**
         * Locked rotor ratio (R/X). Used for short circuit data exchange according
         * to IEC 60909.
         */
        public Double getRxLockedRotorRatio () { return rxLockedRotorRatio; }
        public void setRxLockedRotorRatio ( Double rxLockedRotorRatio ) { this.rxLockedRotorRatio = rxLockedRotorRatio; }
        @Basic()
        @Column(name="\"rxLockedRotorRatio\"")
        private Double rxLockedRotorRatio ;
         
        /**
         * Transient rotor time constant (greater than tppo).
         */
        public Double getTpo () { return tpo; }
        public void setTpo ( Double tpo ) { this.tpo = tpo; }
        @Basic()
        @Column(name="\"tpo\"")
        private Double tpo ;
         
        /**
         * Sub-transient rotor time constant (greater than 0).
         */
        public Double getTppo () { return tppo; }
        public void setTppo ( Double tppo ) { this.tppo = tppo; }
        @Basic()
        @Column(name="\"tppo\"")
        private Double tppo ;
         
        /**
         * Damper 1 winding leakage reactance.
         */
        public Double getXlr1 () { return xlr1; }
        public void setXlr1 ( Double xlr1 ) { this.xlr1 = xlr1; }
        @Basic()
        @Column(name="\"xlr1\"")
        private Double xlr1 ;
         
        /**
         * Damper 2 winding leakage reactance.
         */
        public Double getXlr2 () { return xlr2; }
        public void setXlr2 ( Double xlr2 ) { this.xlr2 = xlr2; }
        @Basic()
        @Column(name="\"xlr2\"")
        private Double xlr2 ;
         
        /**
         * Magnetizing reactance.
         */
        public Double getXm () { return xm; }
        public void setXm ( Double xm ) { this.xm = xm; }
        @Basic()
        @Column(name="\"xm\"")
        private Double xm ;
         
        /**
         * Transient reactance (unsaturated) (greater than or equal to xpp).
         */
        public Double getXp () { return xp; }
        public void setXp ( Double xp ) { this.xp = xp; }
        @Basic()
        @Column(name="\"xp\"")
        private Double xp ;
         
        /**
         * Sub-transient reactance (unsaturated).
         */
        public Double getXpp () { return xpp; }
        public void setXpp ( Double xpp ) { this.xpp = xpp; }
        @Basic()
        @Column(name="\"xpp\"")
        private Double xpp ;
         
        /**
         * Synchronous reactance (greater than xp).
         */
        public Double getXs () { return xs; }
        public void setXs ( Double xs ) { this.xs = xs; }
        @Basic()
        @Column(name="\"xs\"")
        private Double xs ;
         
        /**
         * Asynchronous machine dynamics model used to describe dynamic behaviour
         * of this asynchronous machine.
         */
        public AsynchronousMachineDynamics getAsynchronousMachineDynamics () { return asynchronousMachineDynamics; }
        public void setAsynchronousMachineDynamics ( AsynchronousMachineDynamics asynchronousMachineDynamics ) { this.asynchronousMachineDynamics = asynchronousMachineDynamics; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AsynchronousMachineDynamics\"")
        private AsynchronousMachineDynamics asynchronousMachineDynamics ;
         
    }
    /**
     * Asynchronous machine whose behaviour is described by reference to a standard
     * model expressed in either time constant reactance form or equivalent circuit
     * form <font color="#0f0f0f">or by definition of a user-defined model.</font>
     * Parameter details:
     * <ol>
     * <li>Asynchronous machine parameters such as <i>Xl, Xs,</i> etc. are actually
     * used as inductances in the model, but are commonly referred to as reactances
     * since, at nominal frequency, the PU values are the same. However, some
     * references use the symbol <i>L</i> instead of <i>X</i>.</li>
     * </ol>
     */
    @Entity
    @Table(name="\"AsynchronousMachineDynamics\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class AsynchronousMachineDynamics
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    /**
     * Kind of Asynchronous Machine.
     */
    @Entity
    @Table(name="\"AsynchronousMachineKind\"")
    public static class AsynchronousMachineKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Kind of Asynchronous Machine.
     */
    @Entity
    @Table(name="\"AsynchronousMachineKind1\"")
    public static class AsynchronousMachineKind1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Defines a system base voltage which is referenced.
     */
    @Entity
    @Table(name="\"BaseVoltage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class BaseVoltage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A mechanical switching device capable of making, carrying, and breaking
     * currents under normal circuit conditions and also making, carrying for
     * a specified time, and breaking currents under specified abnormal circuit
     * conditions e.g. those of short circuit.
     */
    @Entity
    @Table(name="\"Breaker\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Breaker extends ProtectedSwitch
    {
        /**
         * The transition time from open to close.
         */
        public Double getInTransitTime () { return inTransitTime; }
        public void setInTransitTime ( Double inTransitTime ) { this.inTransitTime = inTransitTime; }
        @Basic()
        @Column(name="\"inTransitTime\"")
        private Double inTransitTime ;
         
    }
    /**
     * A conductor, or group of conductors, with negligible impedance, that serve
     * to connect other conducting equipment within a single substation.
     * Voltage measurements are typically obtained from voltage transformers that
     * are connected to busbar sections. A bus bar section may have many physical
     * terminals but for analysis is modelled with exactly one logical terminal.
     */
    @Entity
    @Table(name="\"BusbarSection\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class BusbarSection extends Connector
    {
        /**
         * Maximum allowable peak short-circuit current of busbar (Ipmax in IEC 60909-0).
         * Mechanical limit of the busbar in the substation itself. Used for short
         * circuit data exchange according to IEC 60909.
         */
        public Double getIpMax () { return ipMax; }
        public void setIpMax ( Double ipMax ) { this.ipMax = ipMax; }
        @Basic()
        @Column(name="\"ipMax\"")
        private Double ipMax ;
         
        /**
         * A VoltageControlZone is controlled by a designated BusbarSection.
         */
        public VoltageControlZone getVoltageControlZone () { return voltageControlZone; }
        public void setVoltageControlZone ( VoltageControlZone voltageControlZone ) { this.voltageControlZone = voltageControlZone; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"VoltageControlZone\"")
        private VoltageControlZone voltageControlZone ;
         
    }
    /**
     * A Clamp is a galvanic connection at a line segment where other equipment
     * is connected. A Clamp does not cut the line segment.
     * A Clamp is ConductingEquipment and has one Terminal with an associated
     * ConnectivityNode. Any other ConductingEquipment can be connected to the
     * Clamp ConnectivityNode.
     */
    @Entity
    @Table(name="\"Clamp\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Clamp
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The length to the place where the clamp is located starting from side one
         * of the line segment, i.e. the line segment terminal with sequence number
         * equal to 1.
         */
        public Double getLengthFromTerminal1 () { return lengthFromTerminal1; }
        public void setLengthFromTerminal1 ( Double lengthFromTerminal1 ) { this.lengthFromTerminal1 = lengthFromTerminal1; }
        @Basic()
        @Column(name="\"lengthFromTerminal1\"")
        private Double lengthFromTerminal1 ;
         
        /**
         * The line segment to which the clamp is connected.
         */
        public ACLineSegment getACLineSegment () { return aCLineSegment; }
        public void setACLineSegment ( ACLineSegment aCLineSegment ) { this.aCLineSegment = aCLineSegment; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ACLineSegment\"")
        private ACLineSegment aCLineSegment ;
         
        /**
         * The clamp action that is performed on the clamp
         */
        public ClampAction getClampAction () { return clampAction; }
        public void setClampAction ( ClampAction clampAction ) { this.clampAction = clampAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ClampAction\"")
        private ClampAction clampAction ;
         
        /**
         * Action taken with this jumper.
         */
        public JumperAction getJumperAction () { return jumperAction; }
        public void setJumperAction ( JumperAction jumperAction ) { this.jumperAction = jumperAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"JumperAction\"")
        private JumperAction jumperAction ;
         
    }
    /**
     * Action on Clamp as a switching step
     */
    @Entity
    @Table(name="\"ClampAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ClampAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A model of a set of individual Switches normally enclosed within the same
     * cabinet and possibly with interlocks that restrict the combination of switch
     * positions. These are typically found in medium voltage distribution networks.
     * A CompositeSwitch could represent a Ring-Main-Unit (RMU), or pad-mounted
     * switchgear, with primitive internal devices such as an internal bus-bar
     * plus 3 or 4 internal switches each of which may individually be open or
     * closed. A CompositeSwitch and a set of contained Switches can also be used
     * to represent a multi-position switch e.g. a switch that can connect a circuit
     * to Ground, Open or Busbar.
     */
    @Entity
    @Table(name="\"CompositeSwitch\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CompositeSwitch
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * An alphanumeric code that can be used as a reference to extra information
         * such as the description of the interlocking scheme if any.
         */
        public String getCompositeSwitchType () { return compositeSwitchType; }
        public void setCompositeSwitchType ( String compositeSwitchType ) { this.compositeSwitchType = compositeSwitchType; }
        @Basic()
        @Column(name="\"compositeSwitchType\"")
        private String compositeSwitchType ;
         
    }
    /**
     * Combination of conducting material with consistent electrical characteristics,
     * building a single electrical system, used to carry current between points
     * in the power system.
     */
    @Entity
    @Table(name="\"Conductor\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Conductor
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Segment length for calculating line section capabilities.
         */
        public Double getLength () { return length; }
        public void setLength ( Double length ) { this.length = length; }
        @Basic()
        @Column(name="\"length\"")
        private Double length ;
         
    }
    /**
     * A conductor, or group of conductors, with negligible impedance, that serve
     * to connect other conducting equipment within a single substation and are
     * modelled with a single logical terminal.
     */
    @Entity
    @Table(name="\"Connector\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Connector
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    /**
     * Method of cooling a machine.
     */
    @Entity
    @Table(name="\"CoolantType\"")
    public static class CoolantType
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A cut separates a line segment into two parts. The cut appears as a switch
     * inserted between these two parts and connects them together. As the cut
     * is normally open there is no galvanic connection between the two line segment
     * parts. But it is possible to close the cut to get galvanic connection.
     * The cut terminals are oriented towards the line segment terminals with
     * the same sequence number. Hence the cut terminal with sequence number equal
     * to 1 is oriented to the line segment's terminal with sequence number equal
     * to 1.
     * The cut terminals also act as connection points for jumpers and other equipment,
     * e.g. a mobile generator. To enable this, connectivity nodes are placed
     * at the cut terminals. Once the connectivity nodes are in place any conducting
     * equipment can be connected at them.
     */
    @Entity
    @Table(name="\"Cut\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Cut extends Switch
    {
        /**
         * The length to the place where the cut is located starting from side one
         * of the cut line segment, i.e. the line segment Terminal with sequenceNumber
         * equal to 1.
         */
        public Double getLengthFromTerminal1 () { return lengthFromTerminal1; }
        public void setLengthFromTerminal1 ( Double lengthFromTerminal1 ) { this.lengthFromTerminal1 = lengthFromTerminal1; }
        @Basic()
        @Column(name="\"lengthFromTerminal1\"")
        private Double lengthFromTerminal1 ;
         
        /**
         * The line segment to which the cut is applied.
         */
        public ACLineSegment getACLineSegment () { return aCLineSegment; }
        public void setACLineSegment ( ACLineSegment aCLineSegment ) { this.aCLineSegment = aCLineSegment; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ACLineSegment\"")
        private ACLineSegment aCLineSegment ;
         
        /**
         * Action taken with this cut.
         */
        public CutAction getCutAction () { return cutAction; }
        public void setCutAction ( CutAction cutAction ) { this.cutAction = cutAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CutAction\"")
        private CutAction cutAction ;
         
    }
    /**
     * Action on cut as a switching step.
     */
    @Entity
    @Table(name="\"CutAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CutAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A circuit breaking device including disconnecting function, eliminating
     * the need for separate disconnectors.
     */
    @Entity
    @Table(name="\"DisconnectingCircuitBreaker\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class DisconnectingCircuitBreaker extends Breaker
    {
    }
    /**
     * A circuit breaking device including disconnecting function, eliminating
     * the need for separate disconnectors.
     */
    @Entity
    @Table(name="\"DisconnectingCircuitBreaker1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class DisconnectingCircuitBreaker1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A manually operated or motor operated mechanical switching device used
     * for changing the connections in a circuit, or for isolating a circuit or
     * equipment from a source of power. It is required to open or close circuits
     * when negligible current is broken or made.
     */
    @Entity
    @Table(name="\"Disconnector\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Disconnector extends Switch
    {
    }
    /**
     * A manually operated or motor operated mechanical switching device used
     * for changing the connections in a circuit, or for isolating a circuit or
     * equipment from a source of power. It is required to open or close circuits
     * when negligible current is broken or made.
     */
    @Entity
    @Table(name="\"Disconnector1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Disconnector1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A conducting equipment used to represent a connection to ground which is
     * typically used to compensate earth faults. An earth fault compensator device
     * modelled with a single terminal implies a second terminal solidly connected
     * to ground. If two terminals are modelled, the ground is not assumed and
     * normal connection rules apply.
     */
    @Entity
    @Table(name="\"EarthFaultCompensator\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EarthFaultCompensator
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Nominal resistance of device.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
    }
    /**
     * A connection of energy generation or consumption on the power system model.
     */
    @Entity
    @Table(name="\"EnergyConnection\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergyConnection
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Generic user of energy - a point of consumption on the power system model.
     * EnergyConsumer.pfixed, .qfixed, .pfixedPct and .qfixedPct have meaning
     * only if there is no LoadResponseCharacteristic associated with EnergyConsumer
     * or if LoadResponseCharacteristic.exponentModel is set to False.
     */
    @Entity
    @Table(name="\"EnergyConsumer\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class EnergyConsumer extends EnergyConnection
    {
        /**
         * Number of individual customers represented by this demand.
         */
        public Integer getCustomerCount () { return customerCount; }
        public void setCustomerCount ( Integer customerCount ) { this.customerCount = customerCount; }
        @Basic()
        @Column(name="\"customerCount\"")
        private Integer customerCount ;
         
        /**
         * Used for Yn and Zn connections. True if the neutral is solidly grounded.
         */
        public Boolean getGrounded () { return grounded; }
        public void setGrounded ( Boolean grounded ) { this.grounded = grounded; }
        @Basic()
        @Column(name="\"grounded\"")
        private Boolean grounded ;
         
        /**
         * Active power of the load. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * For voltage dependent loads the value is at rated voltage.
         * Starting value for a steady state solution.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Active power of the load that is a fixed quantity and does not vary as
         * load group value varies. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         */
        public Double getPfixed () { return pfixed; }
        public void setPfixed ( Double pfixed ) { this.pfixed = pfixed; }
        @Basic()
        @Column(name="\"pfixed\"")
        private Double pfixed ;
         
        /**
         * Fixed active power as a percentage of load group fixed active power. Used
         * to represent the time-varying components. Load sign convention is used,
         * i.e. positive sign means flow out from a node.
         */
        public Double getPfixedPct () { return pfixedPct; }
        public void setPfixedPct ( Double pfixedPct ) { this.pfixedPct = pfixedPct; }
        @Basic()
        @Column(name="\"pfixedPct\"")
        private Double pfixedPct ;
         
        /**
         * The type of phase connection, such as wye or delta.
         */
        public String getPhaseConnection () { return phaseConnection; }
        public void setPhaseConnection ( String phaseConnection ) { this.phaseConnection = phaseConnection; }
        @Basic()
        @Column(name="\"phaseConnection\"")
        private String phaseConnection ;
         
        /**
         * Reactive power of the load. Load sign convention is used, i.e. positive
         * sign means flow out from a node.
         * For voltage dependent loads the value is at rated voltage.
         * Starting value for a steady state solution.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Reactive power of the load that is a fixed quantity and does not vary as
         * load group value varies. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         */
        public Double getQfixed () { return qfixed; }
        public void setQfixed ( Double qfixed ) { this.qfixed = qfixed; }
        @Basic()
        @Column(name="\"qfixed\"")
        private Double qfixed ;
         
        /**
         * Fixed reactive power as a percentage of load group fixed reactive power.
         * Used to represent the time-varying components. Load sign convention is
         * used, i.e. positive sign means flow out from a node.
         */
        public Double getQfixedPct () { return qfixedPct; }
        public void setQfixedPct ( Double qfixedPct ) { this.qfixedPct = qfixedPct; }
        @Basic()
        @Column(name="\"qfixedPct\"")
        private Double qfixedPct ;
         
        /**
         * The energy consumer action that is performed on the energy consumer
         */
        public EnergyConsumerAction getEnergyConsumerAction () { return energyConsumerAction; }
        public void setEnergyConsumerAction ( EnergyConsumerAction energyConsumerAction ) { this.energyConsumerAction = energyConsumerAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EnergyConsumerAction\"")
        private EnergyConsumerAction energyConsumerAction ;
         
        /**
         * Load dynamics model used to describe dynamic behaviour of this energy consumer.
         */
        public LoadDynamics getLoadDynamics () { return loadDynamics; }
        public void setLoadDynamics ( LoadDynamics loadDynamics ) { this.loadDynamics = loadDynamics; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"LoadDynamics\"")
        private LoadDynamics loadDynamics ;
         
        /**
         * The load response characteristic of this load. If missing, this load is
         * assumed to be constant power.
         */
        public LoadResponseCharacteristic getLoadResponse () { return loadResponse; }
        public void setLoadResponse ( LoadResponseCharacteristic loadResponse ) { this.loadResponse = loadResponse; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"LoadResponse\"")
        private LoadResponseCharacteristic loadResponse ;
         
        /**
         * The energy consumer is assigned to this power cut zone.
         */
        public PowerCutZone getPowerCutZone () { return powerCutZone; }
        public void setPowerCutZone ( PowerCutZone powerCutZone ) { this.powerCutZone = powerCutZone; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PowerCutZone\"")
        private PowerCutZone powerCutZone ;
         
    }
    /**
     * Action to connect or disconnect the Energy Consumer from its Terminal
     */
    @Entity
    @Table(name="\"EnergyConsumerAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergyConsumerAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A single phase of an energy consumer.
     */
    @Entity
    @Table(name="\"EnergyConsumerPhase\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergyConsumerPhase
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Active power of the load. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * For voltage dependent loads the value is at rated voltage.
         * Starting value for a steady state solution.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Active power of the load that is a fixed quantity. Load sign convention
         * is used, i.e. positive sign means flow out from a node.
         */
        public Double getPfixed () { return pfixed; }
        public void setPfixed ( Double pfixed ) { this.pfixed = pfixed; }
        @Basic()
        @Column(name="\"pfixed\"")
        private Double pfixed ;
         
        /**
         * Fixed active power as per cent of load group fixed active power. Load sign
         * convention is used, i.e. positive sign means flow out from a node.
         */
        public Double getPfixedPct () { return pfixedPct; }
        public void setPfixedPct ( Double pfixedPct ) { this.pfixedPct = pfixedPct; }
        @Basic()
        @Column(name="\"pfixedPct\"")
        private Double pfixedPct ;
         
        /**
         * Phase of this energy consumer component. If the energy consumer is wye
         * connected, the connection is from the indicated phase to the central ground
         * or neutral point. If the energy consumer is delta connected, the phase
         * indicates an energy consumer connected from the indicated phase to the
         * next logical non-neutral phase.
         */
        public String getPhase () { return phase; }
        public void setPhase ( String phase ) { this.phase = phase; }
        @Basic()
        @Column(name="\"phase\"")
        private String phase ;
         
        /**
         * Reactive power of the load. Load sign convention is used, i.e. positive
         * sign means flow out from a node.
         * For voltage dependent loads the value is at rated voltage.
         * Starting value for a steady state solution.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Reactive power of the load that is a fixed quantity. Load sign convention
         * is used, i.e. positive sign means flow out from a node.
         */
        public Double getQfixed () { return qfixed; }
        public void setQfixed ( Double qfixed ) { this.qfixed = qfixed; }
        @Basic()
        @Column(name="\"qfixed\"")
        private Double qfixed ;
         
        /**
         * Fixed reactive power as per cent of load group fixed reactive power. Load
         * sign convention is used, i.e. positive sign means flow out from a node.
         */
        public Double getQfixedPct () { return qfixedPct; }
        public void setQfixedPct ( Double qfixedPct ) { this.qfixedPct = qfixedPct; }
        @Basic()
        @Column(name="\"qfixedPct\"")
        private Double qfixedPct ;
         
        /**
         * The energy consumer to which this phase belongs.
         */
        public EnergyConsumer getEnergyConsumer () { return energyConsumer; }
        public void setEnergyConsumer ( EnergyConsumer energyConsumer ) { this.energyConsumer = energyConsumer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EnergyConsumer\"")
        private EnergyConsumer energyConsumer ;
         
    }
    /**
     * Used to define the type of generation for scheduling purposes.
     */
    @Entity
    @Table(name="\"EnergySchedulingType\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergySchedulingType
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A generic equivalent for an energy supplier on a transmission or distribution
     * voltage level.
     */
    @Entity
    @Table(name="\"EnergySource\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class EnergySource extends EnergyConnection
    {
        /**
         * High voltage source active injection. Load sign convention is used, i.e.
         * positive sign means flow out from a node.
         * Starting value for steady state solutions.
         */
        public Double getActivePower () { return activePower; }
        public void setActivePower ( Double activePower ) { this.activePower = activePower; }
        @Basic()
        @Column(name="\"activePower\"")
        private Double activePower ;
         
        /**
         * Phase-to-phase nominal voltage.
         */
        public Double getNominalVoltage () { return nominalVoltage; }
        public void setNominalVoltage ( Double nominalVoltage ) { this.nominalVoltage = nominalVoltage; }
        @Basic()
        @Column(name="\"nominalVoltage\"")
        private Double nominalVoltage ;
         
        /**
         * This is the maximum active power that can be produced by the source. Load
         * sign convention is used, i.e. positive sign means flow out from a TopologicalNode
         * (bus) into the conducting equipment.
         */
        public Double getPMax () { return pMax; }
        public void setPMax ( Double pMax ) { this.pMax = pMax; }
        @Basic()
        @Column(name="\"pMax\"")
        private Double pMax ;
         
        /**
         * This is the minimum active power that can be produced by the source. Load
         * sign convention is used, i.e. positive sign means flow out from a TopologicalNode
         * (bus) into the conducting equipment.
         */
        public Double getPMin () { return pMin; }
        public void setPMin ( Double pMin ) { this.pMin = pMin; }
        @Basic()
        @Column(name="\"pMin\"")
        private Double pMin ;
         
        /**
         * Positive sequence Thevenin resistance.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence Thevenin resistance.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * High voltage source reactive injection. Load sign convention is used, i.e.
         * positive sign means flow out from a node.
         * Starting value for steady state solutions.
         */
        public Double getReactivePower () { return reactivePower; }
        public void setReactivePower ( Double reactivePower ) { this.reactivePower = reactivePower; }
        @Basic()
        @Column(name="\"reactivePower\"")
        private Double reactivePower ;
         
        /**
         * Negative sequence Thevenin resistance.
         */
        public Double getRn () { return rn; }
        public void setRn ( Double rn ) { this.rn = rn; }
        @Basic()
        @Column(name="\"rn\"")
        private Double rn ;
         
        /**
         * Phase angle of a-phase open circuit used when voltage characteristics need
         * to be imposed at the node associated with the terminal of the energy source,
         * such as when voltages and angles from the transmission level are used as
         * input to the distribution network. The attribute shall be a positive value
         * or zero.
         */
        public Double getVoltageAngle () { return voltageAngle; }
        public void setVoltageAngle ( Double voltageAngle ) { this.voltageAngle = voltageAngle; }
        @Basic()
        @Column(name="\"voltageAngle\"")
        private Double voltageAngle ;
         
        /**
         * Phase-to-phase open circuit voltage magnitude used when voltage characteristics
         * need to be imposed at the node associated with the terminal of the energy
         * source, such as when voltages and angles from the transmission level are
         * used as input to the distribution network. The attribute shall be a positive
         * value or zero.
         */
        public Double getVoltageMagnitude () { return voltageMagnitude; }
        public void setVoltageMagnitude ( Double voltageMagnitude ) { this.voltageMagnitude = voltageMagnitude; }
        @Basic()
        @Column(name="\"voltageMagnitude\"")
        private Double voltageMagnitude ;
         
        /**
         * Positive sequence Thevenin reactance.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero sequence Thevenin reactance.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * Negative sequence Thevenin reactance.
         */
        public Double getXn () { return xn; }
        public void setXn ( Double xn ) { this.xn = xn; }
        @Basic()
        @Column(name="\"xn\"")
        private Double xn ;
         
        /**
         * Energy Scheduling Type of an Energy Source.
         */
        public EnergySchedulingType getEnergySchedulingType () { return energySchedulingType; }
        public void setEnergySchedulingType ( EnergySchedulingType energySchedulingType ) { this.energySchedulingType = energySchedulingType; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EnergySchedulingType\"")
        private EnergySchedulingType energySchedulingType ;
         
        /**
         * Action taken with this energy source.
         */
        public EnergySourceAction getEnergySourceAction () { return energySourceAction; }
        public void setEnergySourceAction ( EnergySourceAction energySourceAction ) { this.energySourceAction = energySourceAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EnergySourceAction\"")
        private EnergySourceAction energySourceAction ;
         
    }
    /**
     * Action on energy source as a switching step.
     */
    @Entity
    @Table(name="\"EnergySourceAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergySourceAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Represents the single phase information of an unbalanced energy source.
     */
    @Entity
    @Table(name="\"EnergySourcePhase\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergySourcePhase
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Phase of this energy source component. If the energy source wye connected,
         * the connection is from the indicated phase to the central ground or neutral
         * point. If the energy source is delta connected, the phase indicates an
         * energy source connected from the indicated phase to the next logical non-neutral
         * phase.
         */
        public String getPhase () { return phase; }
        public void setPhase ( String phase ) { this.phase = phase; }
        @Basic()
        @Column(name="\"phase\"")
        private String phase ;
         
        /**
         * The energy sourceto which the phase belongs.
         */
        public EnergySource getEnergySource () { return energySource; }
        public void setEnergySource ( EnergySource energySource ) { this.energySource = energySource; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EnergySource\"")
        private EnergySource energySource ;
         
    }
    /**
     * This class represents the external network and it is used for IEC 60909
     * calculations.
     */
    @Entity
    @Table(name="\"ExternalNetworkInjection\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class ExternalNetworkInjection extends RegulatingCondEq
    {
        /**
         * Power Frequency Bias. This is the change in power injection divided by
         * the change in frequency and negated. A positive value of the power frequency
         * bias provides additional power injection upon a drop in frequency.
         */
        public Double getGovernorSCD () { return governorSCD; }
        public void setGovernorSCD ( Double governorSCD ) { this.governorSCD = governorSCD; }
        @Basic()
        @Column(name="\"governorSCD\"")
        private Double governorSCD ;
         
        /**
         * Indicates whether initial symmetrical short-circuit current and power have
         * been calculated according to IEC (Ik"). Used only if short circuit calculations
         * are done according to superposition method.
         */
        public Boolean getIkSecond () { return ikSecond; }
        public void setIkSecond ( Boolean ikSecond ) { this.ikSecond = ikSecond; }
        @Basic()
        @Column(name="\"ikSecond\"")
        private Boolean ikSecond ;
         
        /**
         * Maximum initial symmetrical short-circuit currents (Ik" max) in A (Ik"
         * = Sk"/(SQRT(3) Un)). Used for short circuit data exchange according to
         * IEC 60909.
         */
        public Double getMaxInitialSymShCCurrent () { return maxInitialSymShCCurrent; }
        public void setMaxInitialSymShCCurrent ( Double maxInitialSymShCCurrent ) { this.maxInitialSymShCCurrent = maxInitialSymShCCurrent; }
        @Basic()
        @Column(name="\"maxInitialSymShCCurrent\"")
        private Double maxInitialSymShCCurrent ;
         
        /**
         * Maximum active power of the injection.
         */
        public Double getMaxP () { return maxP; }
        public void setMaxP ( Double maxP ) { this.maxP = maxP; }
        @Basic()
        @Column(name="\"maxP\"")
        private Double maxP ;
         
        /**
         * Maximum reactive power limit. It is used for modelling of infeed for load
         * flow exchange and not for short circuit modelling.
         */
        public Double getMaxQ () { return maxQ; }
        public void setMaxQ ( Double maxQ ) { this.maxQ = maxQ; }
        @Basic()
        @Column(name="\"maxQ\"")
        private Double maxQ ;
         
        /**
         * Maximum ratio of zero sequence resistance of Network Feeder to its zero
         * sequence reactance (R(0)/X(0) max). Used for short circuit data exchange
         * according to IEC 60909.
         */
        public Double getMaxR0ToX0Ratio () { return maxR0ToX0Ratio; }
        public void setMaxR0ToX0Ratio ( Double maxR0ToX0Ratio ) { this.maxR0ToX0Ratio = maxR0ToX0Ratio; }
        @Basic()
        @Column(name="\"maxR0ToX0Ratio\"")
        private Double maxR0ToX0Ratio ;
         
        /**
         * Maximum ratio of positive sequence resistance of Network Feeder to its
         * positive sequence reactance (R(1)/X(1) max). Used for short circuit data
         * exchange according to IEC 60909.
         */
        public Double getMaxR1ToX1Ratio () { return maxR1ToX1Ratio; }
        public void setMaxR1ToX1Ratio ( Double maxR1ToX1Ratio ) { this.maxR1ToX1Ratio = maxR1ToX1Ratio; }
        @Basic()
        @Column(name="\"maxR1ToX1Ratio\"")
        private Double maxR1ToX1Ratio ;
         
        /**
         * Maximum ratio of zero sequence impedance to its positive sequence impedance
         * (Z(0)/Z(1) max). Used for short circuit data exchange according to IEC
         * 60909.
         */
        public Double getMaxZ0ToZ1Ratio () { return maxZ0ToZ1Ratio; }
        public void setMaxZ0ToZ1Ratio ( Double maxZ0ToZ1Ratio ) { this.maxZ0ToZ1Ratio = maxZ0ToZ1Ratio; }
        @Basic()
        @Column(name="\"maxZ0ToZ1Ratio\"")
        private Double maxZ0ToZ1Ratio ;
         
        /**
         * Minimum initial symmetrical short-circuit currents (Ik" min) in A (Ik"
         * = Sk"/(SQRT(3) Un)). Used for short circuit data exchange according to
         * IEC 60909.
         */
        public Double getMinInitialSymShCCurrent () { return minInitialSymShCCurrent; }
        public void setMinInitialSymShCCurrent ( Double minInitialSymShCCurrent ) { this.minInitialSymShCCurrent = minInitialSymShCCurrent; }
        @Basic()
        @Column(name="\"minInitialSymShCCurrent\"")
        private Double minInitialSymShCCurrent ;
         
        /**
         * Minimum active power of the injection.
         */
        public Double getMinP () { return minP; }
        public void setMinP ( Double minP ) { this.minP = minP; }
        @Basic()
        @Column(name="\"minP\"")
        private Double minP ;
         
        /**
         * Minimum reactive power limit. It is used for modelling of infeed for load
         * flow exchange and not for short circuit modelling.
         */
        public Double getMinQ () { return minQ; }
        public void setMinQ ( Double minQ ) { this.minQ = minQ; }
        @Basic()
        @Column(name="\"minQ\"")
        private Double minQ ;
         
        /**
         * Indicates whether initial symmetrical short-circuit current and power have
         * been calculated according to IEC (Ik"). Used for short circuit data exchange
         * according to IEC 6090.
         */
        public Double getMinR0ToX0Ratio () { return minR0ToX0Ratio; }
        public void setMinR0ToX0Ratio ( Double minR0ToX0Ratio ) { this.minR0ToX0Ratio = minR0ToX0Ratio; }
        @Basic()
        @Column(name="\"minR0ToX0Ratio\"")
        private Double minR0ToX0Ratio ;
         
        /**
         * Minimum ratio of positive sequence resistance of Network Feeder to its
         * positive sequence reactance (R(1)/X(1) min). Used for short circuit data
         * exchange according to IEC 60909.
         */
        public Double getMinR1ToX1Ratio () { return minR1ToX1Ratio; }
        public void setMinR1ToX1Ratio ( Double minR1ToX1Ratio ) { this.minR1ToX1Ratio = minR1ToX1Ratio; }
        @Basic()
        @Column(name="\"minR1ToX1Ratio\"")
        private Double minR1ToX1Ratio ;
         
        /**
         * Minimum ratio of zero sequence impedance to its positive sequence impedance
         * (Z(0)/Z(1) min). Used for short circuit data exchange according to IEC
         * 60909.
         */
        public Double getMinZ0ToZ1Ratio () { return minZ0ToZ1Ratio; }
        public void setMinZ0ToZ1Ratio ( Double minZ0ToZ1Ratio ) { this.minZ0ToZ1Ratio = minZ0ToZ1Ratio; }
        @Basic()
        @Column(name="\"minZ0ToZ1Ratio\"")
        private Double minZ0ToZ1Ratio ;
         
        /**
         * Active power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for steady state solutions.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Reactive power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for steady state solutions.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Priority of unit for use as powerflow voltage phase angle reference bus
         * selection. 0 = don t care (default) 1 = highest priority. 2 is less than
         * 1 and so on.
         */
        public Integer getReferencePriority () { return referencePriority; }
        public void setReferencePriority ( Integer referencePriority ) { this.referencePriority = referencePriority; }
        @Basic()
        @Column(name="\"referencePriority\"")
        private Integer referencePriority ;
         
        /**
         * Voltage factor in pu, which was used to calculate short-circuit current
         * Ik" and power Sk". Used only if short circuit calculations are done according
         * to superposition method.
         */
        public Double getVoltageFactor () { return voltageFactor; }
        public void setVoltageFactor ( Double voltageFactor ) { this.voltageFactor = voltageFactor; }
        @Basic()
        @Column(name="\"voltageFactor\"")
        private Double voltageFactor ;
         
    }
    /**
     * A device to convert from one frequency to another (e.g., frequency F1 to
     * F2) comprises a pair of FrequencyConverter instances. One converts from
     * F1 to DC, the other converts the DC to F2.
     */
    @Entity
    @Table(name="\"FrequencyConverter\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class FrequencyConverter extends RegulatingCondEq
    {
        /**
         * Frequency on the AC side.
         */
        public Double getFrequency () { return frequency; }
        public void setFrequency ( Double frequency ) { this.frequency = frequency; }
        @Basic()
        @Column(name="\"frequency\"")
        private Double frequency ;
         
        /**
         * The maximum active power on the DC side at which the frequency converter
         * should operate.
         */
        public Double getMaxP () { return maxP; }
        public void setMaxP ( Double maxP ) { this.maxP = maxP; }
        @Basic()
        @Column(name="\"maxP\"")
        private Double maxP ;
         
        /**
         * The maximum voltage on the DC side at which the frequency converter should
         * operate.
         */
        public Double getMaxU () { return maxU; }
        public void setMaxU ( Double maxU ) { this.maxU = maxU; }
        @Basic()
        @Column(name="\"maxU\"")
        private Double maxU ;
         
        /**
         * The minimum active power on the DC side at which the frequency converter
         * should operate.
         */
        public Double getMinP () { return minP; }
        public void setMinP ( Double minP ) { this.minP = minP; }
        @Basic()
        @Column(name="\"minP\"")
        private Double minP ;
         
        /**
         * The minimum voltage on the DC side at which the frequency converter should
         * operate.
         */
        public Double getMinU () { return minU; }
        public void setMinU ( Double minU ) { this.minU = minU; }
        @Basic()
        @Column(name="\"minU\"")
        private Double minU ;
         
    }
    /**
     * An overcurrent protective device with a circuit opening fusible part that
     * is heated and severed by the passage of overcurrent through it. A fuse
     * is considered a switching device because it breaks current.
     */
    @Entity
    @Table(name="\"Fuse\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Fuse extends Switch
    {
    }
    /**
     * A single or set of synchronous machines for converting mechanical power
     * into alternating-current power. For example, individual machines within
     * a set may be defined for scheduling purposes while a single control signal
     * is derived for the set. In this case there would be a GeneratingUnit for
     * each member of the set and an additional GeneratingUnit corresponding to
     * the set.
     */
    @Entity
    @Table(name="\"GeneratingUnit\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GeneratingUnit
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A point where the system is grounded used for connecting conducting equipment
     * to ground. The power system model can have any number of grounds.
     */
    @Entity
    @Table(name="\"Ground\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Ground
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Action taken with this ground.
         */
        public GroundAction getGroundAction () { return groundAction; }
        public void setGroundAction ( GroundAction groundAction ) { this.groundAction = groundAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GroundAction\"")
        private GroundAction groundAction ;
         
    }
    /**
     * Action on ground as a switching step.
     */
    @Entity
    @Table(name="\"GroundAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GroundAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A manually operated or motor operated mechanical switching device used
     * for isolating a circuit or equipment from ground.
     */
    @Entity
    @Table(name="\"GroundDisconnector\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class GroundDisconnector extends Switch
    {
    }
    /**
     * A fixed impedance device used for grounding.
     */
    @Entity
    @Table(name="\"GroundingImpedance\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class GroundingImpedance extends EarthFaultCompensator
    {
        /**
         * Reactance of device.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
    }
    /**
     * A synchronous motor-driven pump, typically associated with a pumped storage
     * plant.
     */
    @Entity
    @Table(name="\"HydroPump\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroPump
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A short section of conductor with negligible impedance which can be manually
     * removed and replaced if the circuit is de-energized. Note that zero-impedance
     * branches can potentially be modelled by other equipment types.
     */
    @Entity
    @Table(name="\"Jumper\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Jumper extends Switch
    {
        /**
         * Action taken with this jumper.
         */
        public JumperAction getJumperAction () { return jumperAction; }
        public void setJumperAction ( JumperAction jumperAction ) { this.jumperAction = jumperAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"JumperAction\"")
        private JumperAction jumperAction ;
         
    }
    /**
     * Action on jumper as a switching step.
     */
    @Entity
    @Table(name="\"JumperAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class JumperAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A point where one or more conducting equipments are connected with zero
     * resistance.
     */
    @Entity
    @Table(name="\"Junction\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Junction extends Connector
    {
    }
    /**
     * Contains equipment beyond a substation belonging to a power transmission
     * line.
     */
    @Entity
    @Table(name="\"Line\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Line
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The sub-geographical region of the line.
         */
        public SubGeographicalRegion getRegion () { return region; }
        public void setRegion ( SubGeographicalRegion region ) { this.region = region; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Region\"")
        private SubGeographicalRegion region ;
         
    }
    /**
     * A linear shunt compensator has banks or sections with equal admittance
     * values.
     */
    @Entity
    @Table(name="\"LinearShuntCompensator\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class LinearShuntCompensator extends ShuntCompensator
    {
        /**
         * Zero sequence shunt (charging) susceptance per section.
         */
        public Double getB0PerSection () { return b0PerSection; }
        public void setB0PerSection ( Double b0PerSection ) { this.b0PerSection = b0PerSection; }
        @Basic()
        @Column(name="\"b0PerSection\"")
        private Double b0PerSection ;
         
        /**
         * Positive sequence shunt (charging) susceptance per section.
         */
        public Double getBPerSection () { return bPerSection; }
        public void setBPerSection ( Double bPerSection ) { this.bPerSection = bPerSection; }
        @Basic()
        @Column(name="\"bPerSection\"")
        private Double bPerSection ;
         
        /**
         * Zero sequence shunt (charging) conductance per section.
         */
        public Double getG0PerSection () { return g0PerSection; }
        public void setG0PerSection ( Double g0PerSection ) { this.g0PerSection = g0PerSection; }
        @Basic()
        @Column(name="\"g0PerSection\"")
        private Double g0PerSection ;
         
        /**
         * Positive sequence shunt (charging) conductance per section.
         */
        public Double getGPerSection () { return gPerSection; }
        public void setGPerSection ( Double gPerSection ) { this.gPerSection = gPerSection; }
        @Basic()
        @Column(name="\"gPerSection\"")
        private Double gPerSection ;
         
    }
    /**
     * A per phase linear shunt compensator has banks or sections with equal admittance
     * values.
     */
    @Entity
    @Table(name="\"LinearShuntCompensatorPhase\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class LinearShuntCompensatorPhase extends ShuntCompensatorPhase
    {
        /**
         * Susceptance per section of the phase if shunt compensator is wye connected.
         * Susceptance per section phase to phase if shunt compensator is delta connected.
         */
        public Double getBPerSection () { return bPerSection; }
        public void setBPerSection ( Double bPerSection ) { this.bPerSection = bPerSection; }
        @Basic()
        @Column(name="\"bPerSection\"")
        private Double bPerSection ;
         
        /**
         * Conductance per section for this phase if shunt compensator is wye connected.
         * Conductance per section phase to phase if shunt compensator is delta connected.
         */
        public Double getGPerSection () { return gPerSection; }
        public void setGPerSection ( Double gPerSection ) { this.gPerSection = gPerSection; }
        @Basic()
        @Column(name="\"gPerSection\"")
        private Double gPerSection ;
         
    }
    /**
     * A mechanical switching device capable of making, carrying, and breaking
     * currents under normal operating conditions.
     */
    @Entity
    @Table(name="\"LoadBreakSwitch\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class LoadBreakSwitch extends ProtectedSwitch
    {
    }
    /**
     * Load whose behaviour is described by reference to a standard model <font
     * color="#0f0f0f">or by definition of a user-defined model.</font>
     * A standard feature of dynamic load behaviour modelling is the ability to
     * associate the same behaviour to multiple energy consumers by means of a
     * single load definition. The load model is always applied to individual
     * bus loads (energy consumers).
     */
    @Entity
    @Table(name="\"LoadDynamics\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class LoadDynamics
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Models the characteristic response of the load demand due to changes in
     * system conditions such as voltage and frequency. It is not related to demand
     * response.
     * If LoadResponseCharacteristic.exponentModel is True, the exponential voltage
     * or frequency dependent models are specified and used as to calculate active
     * and reactive power components of the load model.
     * The equations to calculate active and reactive power components of the
     * load model are internal to the power flow calculation, hence they use different
     * quantities depending on the use case of the data exchange.
     * The equations for exponential voltage dependent load model injected power
     * are:
     * pInjection= Pnominal* (Voltage/cim:BaseVoltage.nominalVoltage) ** cim:LoadResponseCharacteristic.pVoltageExponent
     * qInjection= Qnominal* (Voltage/cim:BaseVoltage.nominalVoltage) ** cim:LoadResponseCharacteristic.qVoltageExponent
     * Where:
     * 1) * means "multiply" and ** is "raised to power of";
     * 2) Pnominal and Qnominal represent the active power and reactive power
     * at nominal voltage as any load described by the voltage exponential model
     * shall be given at nominal voltage. This means that EnergyConsumer.p and
     * EnergyConsumer.q are at nominal voltage.
     * 3) After power flow is solved:
     * -pInjection and qInjection correspond to SvPowerflow.p and SvPowerflow.q
     * respectively.
     * - Voltage corresponds to SvVoltage.v at the TopologicalNode where the load
     * is connected.
     */
    @Entity
    @Table(name="\"LoadResponseCharacteristic\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class LoadResponseCharacteristic
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * This class represents the zero sequence line mutual coupling.
     */
    @Entity
    @Table(name="\"MutualCoupling\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class MutualCoupling
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Zero sequence mutual coupling shunt (charging) susceptance, uniformly distributed,
         * of the entire line section.
         */
        public Double getB0ch () { return b0ch; }
        public void setB0ch ( Double b0ch ) { this.b0ch = b0ch; }
        @Basic()
        @Column(name="\"b0ch\"")
        private Double b0ch ;
         
        /**
         * Distance to the start of the coupled region from the first line's terminal
         * having sequence number equal to 1.
         */
        public Double getDistance11 () { return distance11; }
        public void setDistance11 ( Double distance11 ) { this.distance11 = distance11; }
        @Basic()
        @Column(name="\"distance11\"")
        private Double distance11 ;
         
        /**
         * Distance to the end of the coupled region from the first line's terminal
         * with sequence number equal to 1.
         */
        public Double getDistance12 () { return distance12; }
        public void setDistance12 ( Double distance12 ) { this.distance12 = distance12; }
        @Basic()
        @Column(name="\"distance12\"")
        private Double distance12 ;
         
        /**
         * Distance to the start of coupled region from the second line's terminal
         * with sequence number equal to 1.
         */
        public Double getDistance21 () { return distance21; }
        public void setDistance21 ( Double distance21 ) { this.distance21 = distance21; }
        @Basic()
        @Column(name="\"distance21\"")
        private Double distance21 ;
         
        /**
         * Distance to the end of coupled region from the second line's terminal with
         * sequence number equal to 1.
         */
        public Double getDistance22 () { return distance22; }
        public void setDistance22 ( Double distance22 ) { this.distance22 = distance22; }
        @Basic()
        @Column(name="\"distance22\"")
        private Double distance22 ;
         
        /**
         * Zero sequence mutual coupling shunt (charging) conductance, uniformly distributed,
         * of the entire line section.
         */
        public Double getG0ch () { return g0ch; }
        public void setG0ch ( Double g0ch ) { this.g0ch = g0ch; }
        @Basic()
        @Column(name="\"g0ch\"")
        private Double g0ch ;
         
        /**
         * Zero sequence branch-to-branch mutual impedance coupling, resistance.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Zero sequence branch-to-branch mutual impedance coupling, reactance.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * The starting terminal for the calculation of distances along the first
         * branch of the mutual coupling. Normally MutualCoupling would only be used
         * for terminals of AC line segments. The first and second terminals of a
         * mutual coupling should point to different AC line segments.
         */
        public Terminal getFirstTerminal () { return firstTerminal; }
        public void setFirstTerminal ( Terminal firstTerminal ) { this.firstTerminal = firstTerminal; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"First_Terminal\"")
        private Terminal firstTerminal ;
         
        /**
         * The starting terminal for the calculation of distances along the second
         * branch of the mutual coupling.
         */
        public Terminal getSecondTerminal () { return secondTerminal; }
        public void setSecondTerminal ( Terminal secondTerminal ) { this.secondTerminal = secondTerminal; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Second_Terminal\"")
        private Terminal secondTerminal ;
         
    }
    /**
     * A non linear shunt compensator has bank or section admittance values that
     * differ. The attributes g, b, g0 and b0 of the associated NonlinearShuntCompensatorPoint
     * describe the total conductance and admittance of a NonlinearShuntCompensatorPoint
     * at a section number specified by NonlinearShuntCompensatorPoint.sectionNumber.
     */
    @Entity
    @Table(name="\"NonlinearShuntCompensator\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class NonlinearShuntCompensator extends ShuntCompensator
    {
    }
    /**
     * A per phase non linear shunt compensator has bank or section admittance
     * values that differ. The attributes g and b of the associated NonlinearShuntCompensatorPhasePoint
     * describe the total conductance and admittance of a NonlinearShuntCompensatorPhasePoint
     * at a section number specified by NonlinearShuntCompensatorPhasePoint.sectionNumber.
     */
    @Entity
    @Table(name="\"NonlinearShuntCompensatorPhase\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class NonlinearShuntCompensatorPhase extends ShuntCompensatorPhase
    {
    }
    /**
     * A per phase non linear shunt compensator bank or section admittance value.
     * The number of NonlinearShuntCompenstorPhasePoint instances associated with
     * a NonlinearShuntCompensatorPhase shall be equal to ShuntCompensatorPhase.maximumSections.
     * ShuntCompensator.sections shall only be set to one of the NonlinearShuntCompenstorPhasePoint.sectionNumber.
     * There is no interpolation between NonlinearShuntCompenstorPhasePoint-s.
     */
    @Entity
    @Table(name="\"NonlinearShuntCompensatorPhasePoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class NonlinearShuntCompensatorPhasePoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Positive sequence shunt (charging) susceptance per section.
         */
        public Double getB () { return b; }
        public void setB ( Double b ) { this.b = b; }
        @Basic()
        @Column(name="\"b\"")
        private Double b ;
         
        /**
         * Positive sequence shunt (charging) conductance per section.
         */
        public Double getG () { return g; }
        public void setG ( Double g ) { this.g = g; }
        @Basic()
        @Column(name="\"g\"")
        private Double g ;
         
        /**
         * The number of the section.
         */
        public Integer getSectionNumber () { return sectionNumber; }
        public void setSectionNumber ( Integer sectionNumber ) { this.sectionNumber = sectionNumber; }
        @Basic()
        @Column(name="\"sectionNumber\"")
        private Integer sectionNumber ;
         
    }
    /**
     * A non linear shunt compensator bank or section admittance value. The number
     * of NonlinearShuntCompenstorPoint instances associated with a NonlinearShuntCompensator
     * shall be equal to ShuntCompensator.maximumSections. ShuntCompensator.sections
     * shall only be set to one of the NonlinearShuntCompenstorPoint.sectionNumber.
     * There is no interpolation between NonlinearShuntCompenstorPoint-s.
     */
    @Entity
    @Table(name="\"NonlinearShuntCompensatorPoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class NonlinearShuntCompensatorPoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Positive sequence shunt (charging) susceptance per section.
         */
        public Double getB () { return b; }
        public void setB ( Double b ) { this.b = b; }
        @Basic()
        @Column(name="\"b\"")
        private Double b ;
         
        /**
         * Zero sequence shunt (charging) susceptance per section.
         */
        public Double getB0 () { return b0; }
        public void setB0 ( Double b0 ) { this.b0 = b0; }
        @Basic()
        @Column(name="\"b0\"")
        private Double b0 ;
         
        /**
         * Positive sequence shunt (charging) conductance per section.
         */
        public Double getG () { return g; }
        public void setG ( Double g ) { this.g = g; }
        @Basic()
        @Column(name="\"g\"")
        private Double g ;
         
        /**
         * Zero sequence shunt (charging) conductance per section.
         */
        public Double getG0 () { return g0; }
        public void setG0 ( Double g0 ) { this.g0 = g0; }
        @Basic()
        @Column(name="\"g0\"")
        private Double g0 ;
         
        /**
         * The number of the section.
         */
        public Integer getSectionNumber () { return sectionNumber; }
        public void setSectionNumber ( Integer sectionNumber ) { this.sectionNumber = sectionNumber; }
        @Basic()
        @Column(name="\"sectionNumber\"")
        private Integer sectionNumber ;
         
    }
    /**
     * Common type for per-length impedance electrical catalogues.
     */
    @Entity
    @Table(name="\"PerLengthImpedance\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PerLengthImpedance extends PerLengthLineParameter
    {
    }
    /**
     * Common type for per-length impedance electrical catalogues.
     */
    @Entity
    @Table(name="\"PerLengthImpedance1\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PerLengthImpedance1 extends PerLengthLineParameter
    {
    }
    /**
     * Common type for per-length electrical catalogues describing line parameters.
     */
    @Entity
    @Table(name="\"PerLengthLineParameter\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PerLengthLineParameter
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         */
        public WireAssemblyInfo getWireAssemblyInfo () { return wireAssemblyInfo; }
        public void setWireAssemblyInfo ( WireAssemblyInfo wireAssemblyInfo ) { this.wireAssemblyInfo = wireAssemblyInfo; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"WireAssemblyInfo\"")
        private WireAssemblyInfo wireAssemblyInfo ;
         
    }
    /**
     * Impedance and admittance parameters per unit length for n-wire unbalanced
     * lines, in matrix form.
     */
    @Entity
    @Table(name="\"PerLengthPhaseImpedance\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PerLengthPhaseImpedance extends PerLengthImpedance
    {
        /**
         * Number of phase, neutral, and other wires retained. Constrains the number
         * of matrix elements and the phase codes that can be used with this matrix.
         */
        public Integer getConductorCount () { return conductorCount; }
        public void setConductorCount ( Integer conductorCount ) { this.conductorCount = conductorCount; }
        @Basic()
        @Column(name="\"conductorCount\"")
        private Integer conductorCount ;
         
    }
    /**
     * Sequence impedance and admittance parameters per unit length, for transposed
     * lines of 1, 2, or 3 phases. For 1-phase lines, define x=x0=xself. For 2-phase
     * lines, define x=xs-xm and x0=xs+xm.
     */
    @Entity
    @Table(name="\"PerLengthSequenceImpedance\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PerLengthSequenceImpedance extends PerLengthImpedance
    {
        /**
         * Zero sequence shunt (charging) susceptance, per unit of length.
         */
        public Double getB0ch () { return b0ch; }
        public void setB0ch ( Double b0ch ) { this.b0ch = b0ch; }
        @Basic()
        @Column(name="\"b0ch\"")
        private Double b0ch ;
         
        /**
         * Positive sequence shunt (charging) susceptance, per unit of length.
         */
        public Double getBch () { return bch; }
        public void setBch ( Double bch ) { this.bch = bch; }
        @Basic()
        @Column(name="\"bch\"")
        private Double bch ;
         
        /**
         * Zero sequence shunt (charging) conductance, per unit of length.
         */
        public Double getG0ch () { return g0ch; }
        public void setG0ch ( Double g0ch ) { this.g0ch = g0ch; }
        @Basic()
        @Column(name="\"g0ch\"")
        private Double g0ch ;
         
        /**
         * Positive sequence shunt (charging) conductance, per unit of length.
         */
        public Double getGch () { return gch; }
        public void setGch ( Double gch ) { this.gch = gch; }
        @Basic()
        @Column(name="\"gch\"")
        private Double gch ;
         
        /**
         * Positive sequence series resistance, per unit of length.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence series resistance, per unit of length.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Positive sequence series reactance, per unit of length.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero sequence series reactance, per unit of length.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
    }
    /**
     * A variable impedance device normally used to offset line charging during
     * single line faults in an ungrounded section of network.
     */
    @Entity
    @Table(name="\"PetersenCoil\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PetersenCoil extends EarthFaultCompensator
    {
        /**
         * The mode of operation of the Petersen coil.
         */
        public String getMode () { return mode; }
        public void setMode ( String mode ) { this.mode = mode; }
        @Basic()
        @Column(name="\"mode\"")
        private String mode ;
         
        /**
         * The nominal voltage for which the coil is designed.
         */
        public Double getNominalU () { return nominalU; }
        public void setNominalU ( Double nominalU ) { this.nominalU = nominalU; }
        @Basic()
        @Column(name="\"nominalU\"")
        private Double nominalU ;
         
        /**
         * The offset current that the Petersen coil controller is operating from
         * the resonant point. This is normally a fixed amount for which the controller
         * is configured and could be positive or negative. Typically 0 to 60 A depending
         * on voltage and resonance conditions.
         */
        public Double getOffsetCurrent () { return offsetCurrent; }
        public void setOffsetCurrent ( Double offsetCurrent ) { this.offsetCurrent = offsetCurrent; }
        @Basic()
        @Column(name="\"offsetCurrent\"")
        private Double offsetCurrent ;
         
        /**
         * The control current used to control the Petersen coil also known as the
         * position current. Typically in the range of 20 mA to 200 mA.
         */
        public Double getPositionCurrent () { return positionCurrent; }
        public void setPositionCurrent ( Double positionCurrent ) { this.positionCurrent = positionCurrent; }
        @Basic()
        @Column(name="\"positionCurrent\"")
        private Double positionCurrent ;
         
        /**
         * The maximum reactance.
         */
        public Double getXGroundMax () { return xGroundMax; }
        public void setXGroundMax ( Double xGroundMax ) { this.xGroundMax = xGroundMax; }
        @Basic()
        @Column(name="\"xGroundMax\"")
        private Double xGroundMax ;
         
        /**
         * The minimum reactance.
         */
        public Double getXGroundMin () { return xGroundMin; }
        public void setXGroundMin ( Double xGroundMin ) { this.xGroundMin = xGroundMin; }
        @Basic()
        @Column(name="\"xGroundMin\"")
        private Double xGroundMin ;
         
        /**
         * The nominal reactance. This is the operating point (normally over compensation)
         * that is defined based on the resonance point in the healthy network condition.
         * The impedance is calculated based on nominal voltage divided by position
         * current.
         */
        public Double getXGroundNominal () { return xGroundNominal; }
        public void setXGroundNominal ( Double xGroundNominal ) { this.xGroundNominal = xGroundNominal; }
        @Basic()
        @Column(name="\"xGroundNominal\"")
        private Double xGroundNominal ;
         
    }
     
    /**
     * The mode of operation for a Petersen coil.
     */
    @Entity
    @Table(name="\"PetersenCoilModeKind\"")
    public static class PetersenCoilModeKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The mode of operation for a Petersen coil.
     */
    @Entity
    @Table(name="\"PetersenCoilModeKind1\"")
    public static class PetersenCoilModeKind1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * An unordered enumeration of phase identifiers. Allows designation of phases
     * for both transmission and distribution equipment, circuits and loads. The
     * enumeration, by itself, does not describe how the phases are connected
     * together or connected to ground. Ground is not explicitly denoted as a
     * phase.
     * Residential and small commercial loads are often served from single-phase,
     * or split-phase, secondary circuits. For the example of s12N, phases 1 and
     * 2 refer to hot wires that are 180 degrees out of phase, while N refers
     * to the neutral wire. Through single-phase transformer connections, these
     * secondary circuits may be served from one or two of the primary phases
     * A, B, and C. For three-phase loads, use the A, B, C phase codes instead
     * of s12N.
     * The integer values are from IEC 61968-9 to support revenue metering applications.
     */
    @Entity
    @Table(name="\"PhaseCode\"")
    public static class PhaseCode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Impedance and conductance matrix element values.
     * The diagonal elements are described by the elements having the same toPhase
     * and fromPhase value and the off diagonal elements have different toPhase
     * and fromPhase values. The matrix can also be stored in symmetric lower
     * triangular format using the row and column attributes, which map to ACLineSegmentPhase.sequenceNumber.
     */
    @Entity
    @Table(name="\"PhaseImpedanceData\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PhaseImpedanceData
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Susceptance matrix element value, per length of unit.
         */
        public Double getB () { return b; }
        public void setB ( Double b ) { this.b = b; }
        @Basic()
        @Column(name="\"b\"")
        private Double b ;
         
        /**
         * The matrix element's column number, in the range 1 to row. Only the lower
         * triangle needs to be stored. This column number matches ACLineSegmentPhase.sequenceNumber.
         */
        public Integer getColumn () { return column; }
        public void setColumn ( Integer column ) { this.column = column; }
        @Basic()
        @Column(name="\"column\"")
        private Integer column ;
         
        /**
         * Refer to the class description.
         */
        public String getFromPhase () { return fromPhase; }
        public void setFromPhase ( String fromPhase ) { this.fromPhase = fromPhase; }
        @Basic()
        @Column(name="\"fromPhase\"")
        private String fromPhase ;
         
        /**
         * Conductance matrix element value, per length of unit.
         */
        public Double getG () { return g; }
        public void setG ( Double g ) { this.g = g; }
        @Basic()
        @Column(name="\"g\"")
        private Double g ;
         
        /**
         * Resistance matrix element value, per length of unit.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * The matrix elements row number, in the range 1 to PerLengthPhaseImpedance.conductorCount.
         * Only the lower triangle needs to be stored. This row number matches ACLineSegmentPhase.sequenceNumber.
         */
        public Integer getRow () { return row; }
        public void setRow ( Integer row ) { this.row = row; }
        @Basic()
        @Column(name="\"row\"")
        private Integer row ;
         
        /**
         * Refer to the class description.
         */
        public String getToPhase () { return toPhase; }
        public void setToPhase ( String toPhase ) { this.toPhase = toPhase; }
        @Basic()
        @Column(name="\"toPhase\"")
        private String toPhase ;
         
        /**
         * Reactance matrix element value, per length of unit.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Conductor phase impedance to which this data belongs.
         */
        public PerLengthPhaseImpedance getPhaseImpedance () { return phaseImpedance; }
        public void setPhaseImpedance ( PerLengthPhaseImpedance phaseImpedance ) { this.phaseImpedance = phaseImpedance; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PhaseImpedance\"")
        private PerLengthPhaseImpedance phaseImpedance ;
         
    }
     
    /**
     * The configuration of phase connections for a single terminal device such
     * as a load or capacitor.
     */
    @Entity
    @Table(name="\"PhaseShuntConnectionKind\"")
    public static class PhaseShuntConnectionKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The configuration of phase connections for a single terminal device such
     * as a load or capacitor.
     */
    @Entity
    @Table(name="\"PhaseShuntConnectionKind1\"")
    public static class PhaseShuntConnectionKind1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A transformer phase shifting tap model that controls the phase angle difference
     * across the power transformer and potentially the active power flow through
     * the power transformer. This phase tap model may also impact the voltage
     * magnitude.
     */
    @Entity
    @Table(name="\"PhaseTapChanger\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PhaseTapChanger extends TapChanger
    {
        /**
         * Transformer end to which this phase tap changer belongs.
         */
        public TransformerEnd getTransformerEnd () { return transformerEnd; }
        public void setTransformerEnd ( TransformerEnd transformerEnd ) { this.transformerEnd = transformerEnd; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TransformerEnd\"")
        private TransformerEnd transformerEnd ;
         
    }
    /**
     * Describes the tap model for an asymmetrical phase shifting transformer
     * in which the difference voltage vector adds to the in-phase winding. The
     * out-of-phase winding is the transformer end where the tap changer is located.
     * The angle between the in-phase and out-of-phase windings is named the winding
     * connection angle. The phase shift depends on both the difference voltage
     * magnitude and the winding connection angle.
     */
    @Entity
    @Table(name="\"PhaseTapChangerAsymmetrical\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PhaseTapChangerAsymmetrical extends PhaseTapChangerNonLinear
    {
        /**
         * The phase angle between the in-phase winding and the out-of -phase winding
         * used for creating phase shift. The out-of-phase winding produces what is
         * known as the difference voltage. Setting this angle to 90 degrees is not
         * the same as a symmetrical transformer. The attribute can only be multiples
         * of 30 degrees. The allowed range is -150 degrees to 150 degrees excluding
         * 0.
         */
        public Double getWindingConnectionAngle () { return windingConnectionAngle; }
        public void setWindingConnectionAngle ( Double windingConnectionAngle ) { this.windingConnectionAngle = windingConnectionAngle; }
        @Basic()
        @Column(name="\"windingConnectionAngle\"")
        private Double windingConnectionAngle ;
         
    }
    /**
     * Describes a tap changer with a linear relation between the tap step and
     * the phase angle difference across the transformer. This is a mathematical
     * model that is an approximation of a real phase tap changer.
     * The phase angle is computed as stepPhaseShiftIncrement times the tap position.
     * The voltage magnitude of both sides is the same.
     */
    @Entity
    @Table(name="\"PhaseTapChangerLinear\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PhaseTapChangerLinear extends PhaseTapChanger
    {
        /**
         * Phase shift per step position. A positive value indicates a positive angle
         * variation from the Terminal at the PowerTransformerEnd, where the TapChanger
         * is located, into the transformer.
         * The actual phase shift increment might be more accurately computed from
         * the symmetrical or asymmetrical models or a tap step table lookup if those
         * are available.
         */
        public Double getStepPhaseShiftIncrement () { return stepPhaseShiftIncrement; }
        public void setStepPhaseShiftIncrement ( Double stepPhaseShiftIncrement ) { this.stepPhaseShiftIncrement = stepPhaseShiftIncrement; }
        @Basic()
        @Column(name="\"stepPhaseShiftIncrement\"")
        private Double stepPhaseShiftIncrement ;
         
        /**
         * The reactance depends on the tap position according to a "u" shaped curve.
         * The maximum reactance (xMax) appears at the low and high tap positions.
         * Depending on the u curve the attribute can be either higher or lower
         * than PowerTransformerEnd.x.
         */
        public Double getXMax () { return xMax; }
        public void setXMax ( Double xMax ) { this.xMax = xMax; }
        @Basic()
        @Column(name="\"xMax\"")
        private Double xMax ;
         
        /**
         * The reactance depends on the tap position according to a "u" shaped curve.
         * The minimum reactance (xMin) appears at the mid tap position. PowerTransformerEnd.x
         * shall be consistent with PhaseTapChangerLinear.xMin and PhaseTapChangerNonLinear.xMin.
         * In case of inconsistency, PowerTransformerEnd.x shall be used.
         */
        public Double getXMin () { return xMin; }
        public void setXMin ( Double xMin ) { this.xMin = xMin; }
        @Basic()
        @Column(name="\"xMin\"")
        private Double xMin ;
         
    }
    /**
     * The non-linear phase tap changer describes the non-linear behaviour of
     * a phase tap changer. This is a base class for the symmetrical and asymmetrical
     * phase tap changer models. The details of these models can be found in IEC
     * 61970-301.
     */
    @Entity
    @Table(name="\"PhaseTapChangerNonLinear\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PhaseTapChangerNonLinear extends PhaseTapChanger
    {
        /**
         * The voltage step increment on the out of phase winding (the PowerTransformerEnd
         * where the TapChanger is located) specified in percent of rated voltage
         * of the PowerTransformerEnd. A positive value means a positive voltage variation
         * from the Terminal at the PowerTransformerEnd, where the TapChanger is located,
         * into the transformer.
         * When the increment is negative, the voltage decreases when the tap step
         * increases.
         */
        public Double getVoltageStepIncrement () { return voltageStepIncrement; }
        public void setVoltageStepIncrement ( Double voltageStepIncrement ) { this.voltageStepIncrement = voltageStepIncrement; }
        @Basic()
        @Column(name="\"voltageStepIncrement\"")
        private Double voltageStepIncrement ;
         
        /**
         * The reactance depends on the tap position according to a "u" shaped curve.
         * The maximum reactance (xMax) appears at the low and high tap positions.
         * Depending on the u curve the attribute can be either higher or lower
         * than PowerTransformerEnd.x.
         */
        public Double getXMax () { return xMax; }
        public void setXMax ( Double xMax ) { this.xMax = xMax; }
        @Basic()
        @Column(name="\"xMax\"")
        private Double xMax ;
         
        /**
         * The reactance depend on the tap position according to a "u" shaped curve.
         * The minimum reactance (xMin) appear at the mid tap position. PowerTransformerEnd.x
         * shall be consistent with PhaseTapChangerLinear.xMin and PhaseTapChangerNonLinear.xMin.
         * In case of inconsistency, PowerTransformerEnd.x shall be used.
         */
        public Double getXMin () { return xMin; }
        public void setXMin ( Double xMin ) { this.xMin = xMin; }
        @Basic()
        @Column(name="\"xMin\"")
        private Double xMin ;
         
    }
    /**
     * Describes a symmetrical phase shifting transformer tap model in which the
     * voltage magnitude of both sides is the same. The difference voltage magnitude
     * is the base in an equal-sided triangle where the sides corresponds to the
     * primary and secondary voltages. The phase angle difference corresponds
     * to the top angle and can be expressed as twice the arctangent of half the
     * total difference voltage.
     */
    @Entity
    @Table(name="\"PhaseTapChangerSymmetrical\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PhaseTapChangerSymmetrical extends PhaseTapChangerNonLinear
    {
    }
    /**
     * Describes a tabular curve for how the phase angle difference and impedance
     * varies with the tap step.
     */
    @Entity
    @Table(name="\"PhaseTapChangerTable\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PhaseTapChangerTable
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Describes each tap step in the phase tap changer tabular curve.
     */
    @Entity
    @Table(name="\"PhaseTapChangerTablePoint\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PhaseTapChangerTablePoint extends TapChangerTablePoint
    {
        /**
         * The angle difference in degrees. A positive value indicates a positive
         * angle variation from the Terminal at the PowerTransformerEnd, where the
         * TapChanger is located, into the transformer.
         */
        public Double getAngle () { return angle; }
        public void setAngle ( Double angle ) { this.angle = angle; }
        @Basic()
        @Column(name="\"angle\"")
        private Double angle ;
         
        /**
         * The table of this point.
         */
        public PhaseTapChangerTable getPhaseTapChangerTable () { return phaseTapChangerTable; }
        public void setPhaseTapChangerTable ( PhaseTapChangerTable phaseTapChangerTable ) { this.phaseTapChangerTable = phaseTapChangerTable; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PhaseTapChangerTable\"")
        private PhaseTapChangerTable phaseTapChangerTable ;
         
    }
    /**
     * Describes a tap changer with a table defining the relation between the
     * tap step and the phase angle difference across the transformer.
     */
    @Entity
    @Table(name="\"PhaseTapChangerTabular\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PhaseTapChangerTabular extends PhaseTapChanger
    {
        /**
         * The phase tap changer table for this phase tap changer.
         */
        public PhaseTapChangerTable getPhaseTapChangerTable () { return phaseTapChangerTable; }
        public void setPhaseTapChangerTable ( PhaseTapChangerTable phaseTapChangerTable ) { this.phaseTapChangerTable = phaseTapChangerTable; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PhaseTapChangerTable\"")
        private PhaseTapChangerTable phaseTapChangerTable ;
         
    }
    /**
     * A Plant is a collection of equipment for purposes of generation.
     */
    @Entity
    @Table(name="\"Plant\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Plant
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * An area or zone of the power system which is used for load shedding purposes.
     */
    @Entity
    @Table(name="\"PowerCutZone\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerCutZone
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A connection to the AC network for energy production or consumption that
     * uses power electronics rather than rotating machines.
     */
    @Entity
    @Table(name="\"PowerElectronicsConnection\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PowerElectronicsConnection extends RegulatingCondEq
    {
        /**
         * Maximum fault current this device will contribute, in per-unit of rated
         * current, before the converter protection will trip or bypass.
         */
        public Double getMaxIFault () { return maxIFault; }
        public void setMaxIFault ( Double maxIFault ) { this.maxIFault = maxIFault; }
        @Basic()
        @Column(name="\"maxIFault\"")
        private Double maxIFault ;
         
        /**
         * Maximum reactive power limit. This is the maximum (nameplate) limit for
         * the unit.
         */
        public Double getMaxQ () { return maxQ; }
        public void setMaxQ ( Double maxQ ) { this.maxQ = maxQ; }
        @Basic()
        @Column(name="\"maxQ\"")
        private Double maxQ ;
         
        /**
         * Minimum reactive power limit for the unit. This is the minimum (nameplate)
         * limit for the unit.
         */
        public Double getMinQ () { return minQ; }
        public void setMinQ ( Double minQ ) { this.minQ = minQ; }
        @Basic()
        @Column(name="\"minQ\"")
        private Double minQ ;
         
        /**
         * Active power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Reactive power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Equivalent resistance (RG) of generator. RG is considered for the calculation
         * of all currents, except for the calculation of the peak current ip. Used
         * for short circuit data exchange according to IEC 60909.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence resistance of the synchronous machine.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Nameplate apparent power rating for the unit.
         * The attribute shall have a positive value.
         */
        public Double getRatedS () { return ratedS; }
        public void setRatedS ( Double ratedS ) { this.ratedS = ratedS; }
        @Basic()
        @Column(name="\"ratedS\"")
        private Double ratedS ;
         
        /**
         * Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
         * for short circuit data exchange according to IEC 60909.
         * The attribute shall be a positive value.
         */
        public Double getRatedU () { return ratedU; }
        public void setRatedU ( Double ratedU ) { this.ratedU = ratedU; }
        @Basic()
        @Column(name="\"ratedU\"")
        private Double ratedU ;
         
        /**
         * Negative sequence Thevenin resistance.
         */
        public Double getRn () { return rn; }
        public void setRn ( Double rn ) { this.rn = rn; }
        @Basic()
        @Column(name="\"rn\"")
        private Double rn ;
         
        /**
         * Positive sequence Thevenin reactance.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero sequence Thevenin reactance.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * Negative sequence Thevenin reactance.
         */
        public Double getXn () { return xn; }
        public void setXn ( Double xn ) { this.xn = xn; }
        @Basic()
        @Column(name="\"xn\"")
        private Double xn ;
         
        /**
         * The wind turbine type 3 or type 4 dynamics model associated with this power
         * electronics connection.
         */
        public WindTurbineType3or4Dynamics getWindTurbineType3or4Dynamics () { return windTurbineType3or4Dynamics; }
        public void setWindTurbineType3or4Dynamics ( WindTurbineType3or4Dynamics windTurbineType3or4Dynamics ) { this.windTurbineType3or4Dynamics = windTurbineType3or4Dynamics; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"WindTurbineType3or4Dynamics\"")
        private WindTurbineType3or4Dynamics windTurbineType3or4Dynamics ;
         
    }
    /**
     * A single phase of a power electronics connection.
     */
    @Entity
    @Table(name="\"PowerElectronicsConnectionPhase\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerElectronicsConnectionPhase
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Active power injection. Load sign convention is used, i.e. positive sign
         * means flow into the equipment from the network.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Phase of this energy producer component. If the energy producer is wye
         * connected, the connection is from the indicated phase to the central ground
         * or neutral point. If the energy producer is delta connected, the phase
         * indicates an energy producer connected from the indicated phase to the
         * next logical non-neutral phase.
         */
        public String getPhase () { return phase; }
        public void setPhase ( String phase ) { this.phase = phase; }
        @Basic()
        @Column(name="\"phase\"")
        private String phase ;
         
        /**
         * Reactive power injection. Load sign convention is used, i.e. positive sign
         * means flow into the equipment from the network.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Power electronics connection of this power electronics connection phase.
         */
        public PowerElectronicsConnection getPowerElectronicsConnection () { return powerElectronicsConnection; }
        public void setPowerElectronicsConnection ( PowerElectronicsConnection powerElectronicsConnection ) { this.powerElectronicsConnection = powerElectronicsConnection; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PowerElectronicsConnection\"")
        private PowerElectronicsConnection powerElectronicsConnection ;
         
    }
    /**
     * An electrical device consisting of two or more coupled windings, with or
     * without a magnetic core, for introducing mutual coupling between electric
     * circuits. Transformers can be used to control voltage and phase shift (active
     * power flow).
     * A power transformer may be composed of separate transformer tanks that
     * need not be identical.
     * A power transformer can be modelled with or without tanks and is intended
     * for use in both balanced and unbalanced representations. A power transformer
     * typically has two terminals, but may have one (grounding), three or more
     * terminals.
     * The inherited association ConductingEquipment.BaseVoltage should not be
     * used. The association from TransformerEnd to BaseVoltage should be used
     * instead.
     */
    @Entity
    @Table(name="\"PowerTransformer\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerTransformer
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The highest operating current (Ib in IEC 60909-0) before short circuit
         * (depends on network configuration and relevant reliability philosophy).
         * It is used for calculation of the impedance correction factor KT defined
         * in IEC 60909-0.
         */
        public Double getBeforeShCircuitHighestOperatingCurrent () { return beforeShCircuitHighestOperatingCurrent; }
        public void setBeforeShCircuitHighestOperatingCurrent ( Double beforeShCircuitHighestOperatingCurrent ) { this.beforeShCircuitHighestOperatingCurrent = beforeShCircuitHighestOperatingCurrent; }
        @Basic()
        @Column(name="\"beforeShCircuitHighestOperatingCurrent\"")
        private Double beforeShCircuitHighestOperatingCurrent ;
         
        /**
         * The highest operating voltage (Ub in IEC 60909-0) before short circuit.
         * It is used for calculation of the impedance correction factor KT defined
         * in IEC 60909-0. This is worst case voltage on the low side winding (3.7.1
         * of IEC 60909:2001). Used to define operating conditions.
         */
        public Double getBeforeShCircuitHighestOperatingVoltage () { return beforeShCircuitHighestOperatingVoltage; }
        public void setBeforeShCircuitHighestOperatingVoltage ( Double beforeShCircuitHighestOperatingVoltage ) { this.beforeShCircuitHighestOperatingVoltage = beforeShCircuitHighestOperatingVoltage; }
        @Basic()
        @Column(name="\"beforeShCircuitHighestOperatingVoltage\"")
        private Double beforeShCircuitHighestOperatingVoltage ;
         
        /**
         * The angle of power factor before short circuit (phib in IEC 60909-0). It
         * is used for calculation of the impedance correction factor KT defined in
         * IEC 60909-0. This is the worst case power factor. Used to define operating
         * conditions.
         */
        public Double getBeforeShortCircuitAnglePf () { return beforeShortCircuitAnglePf; }
        public void setBeforeShortCircuitAnglePf ( Double beforeShortCircuitAnglePf ) { this.beforeShortCircuitAnglePf = beforeShortCircuitAnglePf; }
        @Basic()
        @Column(name="\"beforeShortCircuitAnglePf\"")
        private Double beforeShortCircuitAnglePf ;
         
        /**
         * The minimum operating voltage (uQmin in IEC 60909-0) at the high voltage
         * side (Q side) of the unit transformer of the power station unit. A value
         * well established from long-term operating experience of the system. It
         * is used for calculation of the impedance correction factor KG defined in
         * IEC 60909-0.
         */
        public Double getHighSideMinOperatingU () { return highSideMinOperatingU; }
        public void setHighSideMinOperatingU ( Double highSideMinOperatingU ) { this.highSideMinOperatingU = highSideMinOperatingU; }
        @Basic()
        @Column(name="\"highSideMinOperatingU\"")
        private Double highSideMinOperatingU ;
         
        /**
         * Indicates whether the machine is part of a power station unit. Used for
         * short circuit data exchange according to IEC 60909. It has an impact on
         * how the correction factors are calculated for transformers, since the transformer
         * is not necessarily part of a synchronous machine and generating unit. It
         * is not always possible to derive this information from the model. This
         * is why the attribute is necessary.
         */
        public Boolean getIsPartOfGeneratorUnit () { return isPartOfGeneratorUnit; }
        public void setIsPartOfGeneratorUnit ( Boolean isPartOfGeneratorUnit ) { this.isPartOfGeneratorUnit = isPartOfGeneratorUnit; }
        @Basic()
        @Column(name="\"isPartOfGeneratorUnit\"")
        private Boolean isPartOfGeneratorUnit ;
         
        /**
         * It is used to define if the data (other attributes related to short circuit
         * data exchange) defines long term operational conditions or not. Used for
         * short circuit data exchange according to IEC 60909.
         */
        public Boolean getOperationalValuesConsidered () { return operationalValuesConsidered; }
        public void setOperationalValuesConsidered ( Boolean operationalValuesConsidered ) { this.operationalValuesConsidered = operationalValuesConsidered; }
        @Basic()
        @Column(name="\"operationalValuesConsidered\"")
        private Boolean operationalValuesConsidered ;
         
        /**
         * Vector group of the transformer for protective relaying, e.g., Dyn1. For
         * unbalanced transformers, this may not be simply determined from the constituent
         * winding connections and phase angle displacements.
         * The vectorGroup string consists of the following components in the order
         * listed: high voltage winding connection, mid voltage winding connection
         * (for three winding transformers), phase displacement clock number from
         * 0 to 11, low voltage winding connection
         * phase displacement clock number from 0 to 11. The winding connections are
         * D (delta), Y (wye), YN (wye with neutral), Z (zigzag), ZN (zigzag with
         * neutral), A (auto transformer). Upper case means the high voltage, lower
         * case mid or low. The high voltage winding always has clock position 0 and
         * is not included in the vector group string. Some examples: YNy0 (two winding
         * wye to wye with no phase displacement), YNd11 (two winding wye to delta
         * with 330 degrees phase displacement), YNyn0d5 (three winding transformer
         * wye with neutral high voltage, wye with neutral mid voltage and no phase
         * displacement, delta low voltage with 150 degrees displacement).
         * Phase displacement is defined as the angular difference between the phasors
         * representing the voltages between the neutral point (real or imaginary)
         * and the corresponding terminals of two windings, a positive sequence voltage
         * system being applied to the high-voltage terminals, following each other
         * in alphabetical sequence if they are lettered, or in numerical sequence
         * if they are numbered: the phasors are assumed to rotate in a counter-clockwise
         * sense.
         */
        public String getVectorGroup () { return vectorGroup; }
        public void setVectorGroup ( String vectorGroup ) { this.vectorGroup = vectorGroup; }
        @Basic()
        @Column(name="\"vectorGroup\"")
        private String vectorGroup ;
         
    }
    /**
     * A PowerTransformerEnd is associated with each Terminal of a PowerTransformer.
     * The impedance values r, r0, x, and x0 of a PowerTransformerEnd represents
     * a star equivalent as follows.
     * 1) for a two Terminal PowerTransformer the high voltage (TransformerEnd.endNumber=1)
     * PowerTransformerEnd has non zero values on r, r0, x, and x0 while the low
     * voltage (TransformerEnd.endNumber=2) PowerTransformerEnd has zero values
     * for r, r0, x, and x0. Parameters are always provided, even if the PowerTransformerEnds
     * have the same rated voltage. In this case, the parameters are provided
     * at the PowerTransformerEnd which has TransformerEnd.endNumber equal to
     * 1.
     * 2) for a three Terminal PowerTransformer the three PowerTransformerEnds
     * represent a star equivalent with each leg in the star represented by r,
     * r0, x, and x0 values.
     * 3) For a three Terminal transformer each PowerTransformerEnd shall have
     * g, g0, b and b0 values corresponding to the no load losses distributed
     * on the three PowerTransformerEnds. The total no load loss shunt impedances
     * may also be placed at one of the PowerTransformerEnds, preferably the end
     * numbered 1, having the shunt values on end 1. This is the preferred way.
     * 4) for a PowerTransformer with more than three Terminals the PowerTransformerEnd
     * impedance values cannot be used. Instead use the TransformerMeshImpedance
     * or split the transformer into multiple PowerTransformers.
     * Each PowerTransformerEnd must be contained by a PowerTransformer. Because
     * a PowerTransformerEnd (or any other object) can not be contained by more
     * than one parent, a PowerTransformerEnd can not have an association to an
     * EquipmentContainer (Substation, VoltageLevel, etc).
     */
    @Entity
    @Table(name="\"PowerTransformerEnd\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PowerTransformerEnd extends TransformerEnd
    {
        /**
         * Magnetizing branch susceptance (B mag). The value can be positive or negative.
         */
        public Double getB () { return b; }
        public void setB ( Double b ) { this.b = b; }
        @Basic()
        @Column(name="\"b\"")
        private Double b ;
         
        /**
         * Zero sequence magnetizing branch susceptance.
         */
        public Double getB0 () { return b0; }
        public void setB0 ( Double b0 ) { this.b0 = b0; }
        @Basic()
        @Column(name="\"b0\"")
        private Double b0 ;
         
        /**
         * Kind of connection.
         */
        public String getConnectionKind () { return connectionKind; }
        public void setConnectionKind ( String connectionKind ) { this.connectionKind = connectionKind; }
        @Basic()
        @Column(name="\"connectionKind\"")
        private String connectionKind ;
         
        /**
         * Magnetizing branch conductance.
         */
        public Double getG () { return g; }
        public void setG ( Double g ) { this.g = g; }
        @Basic()
        @Column(name="\"g\"")
        private Double g ;
         
        /**
         * Zero sequence magnetizing branch conductance (star-model).
         */
        public Double getG0 () { return g0; }
        public void setG0 ( Double g0 ) { this.g0 = g0; }
        @Basic()
        @Column(name="\"g0\"")
        private Double g0 ;
         
        /**
         * Terminal voltage phase angle displacement where 360 degrees are represented
         * with clock hours. The valid values are 0 to 11. For example, for the secondary
         * side end of a transformer with vector group code of 'Dyn11', specify the
         * connection kind as wye with neutral and specify the phase angle of the
         * clock as 11. The clock value of the transformer end number specified as
         * 1, is assumed to be zero. Note the transformer end number is not assumed
         * to be the same as the terminal sequence number.
         */
        public Integer getPhaseAngleClock () { return phaseAngleClock; }
        public void setPhaseAngleClock ( Integer phaseAngleClock ) { this.phaseAngleClock = phaseAngleClock; }
        @Basic()
        @Column(name="\"phaseAngleClock\"")
        private Integer phaseAngleClock ;
         
        /**
         * Resistance (star-model) of the transformer end.
         * The attribute shall be equal to or greater than zero for non-equivalent
         * transformers.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence series resistance (star-model) of the transformer end.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Normal apparent power rating.
         * The attribute shall be a positive value. For a two-winding transformer
         * the values for the high and low voltage sides shall be identical.
         */
        public Double getRatedS () { return ratedS; }
        public void setRatedS ( Double ratedS ) { this.ratedS = ratedS; }
        @Basic()
        @Column(name="\"ratedS\"")
        private Double ratedS ;
         
        /**
         * Rated voltage: phase-phase for three-phase windings, and either phase-phase
         * or phase-neutral for single-phase windings.
         * A high voltage side, as given by TransformerEnd.endNumber, shall have a
         * ratedU that is greater than or equal to ratedU for the lower voltage sides.
         * The attribute shall be a positive value.
         */
        public Double getRatedU () { return ratedU; }
        public void setRatedU ( Double ratedU ) { this.ratedU = ratedU; }
        @Basic()
        @Column(name="\"ratedU\"")
        private Double ratedU ;
         
        /**
         * Positive sequence series reactance (star-model) of the transformer end.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero sequence series reactance of the transformer end.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * The power transformer of this power transformer end.
         */
        public PowerTransformer getPowerTransformer () { return powerTransformer; }
        public void setPowerTransformer ( PowerTransformer powerTransformer ) { this.powerTransformer = powerTransformer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PowerTransformer\"")
        private PowerTransformer powerTransformer ;
         
    }
    /**
     * A ProtectedSwitch is a switching device that can be operated by ProtectionEquipment.
     */
    @Entity
    @Table(name="\"ProtectedSwitch\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class ProtectedSwitch extends Switch
    {
        /**
         * The maximum fault current a breaking device can break safely under prescribed
         * conditions of use.
         */
        public Double getBreakingCapacity () { return breakingCapacity; }
        public void setBreakingCapacity ( Double breakingCapacity ) { this.breakingCapacity = breakingCapacity; }
        @Basic()
        @Column(name="\"breakingCapacity\"")
        private Double breakingCapacity ;
         
    }
    /**
     * A tap changer that changes the voltage ratio impacting the voltage magnitude
     * but not the phase angle across the transformer.
     * Angle sign convention (general): Positive value indicates a positive phase
     * shift from the winding where the tap is located to the other winding (for
     * a two-winding transformer).
     */
    @Entity
    @Table(name="\"RatioTapChanger\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class RatioTapChanger extends TapChanger
    {
        /**
         * Tap step increment, in per cent of rated voltage of the power transformer
         * end, per step position.
         * When the increment is negative, the voltage decreases when the tap step
         * increases.
         */
        public Double getStepVoltageIncrement () { return stepVoltageIncrement; }
        public void setStepVoltageIncrement ( Double stepVoltageIncrement ) { this.stepVoltageIncrement = stepVoltageIncrement; }
        @Basic()
        @Column(name="\"stepVoltageIncrement\"")
        private Double stepVoltageIncrement ;
         
        /**
         * Specifies the regulation control mode (voltage or reactive) of the RatioTapChanger.
         */
        public String getTculControlMode () { return tculControlMode; }
        public void setTculControlMode ( String tculControlMode ) { this.tculControlMode = tculControlMode; }
        @Basic()
        @Column(name="\"tculControlMode\"")
        private String tculControlMode ;
         
        /**
         * The tap ratio table for this ratio tap changer.
         */
        public RatioTapChangerTable getRatioTapChangerTable () { return ratioTapChangerTable; }
        public void setRatioTapChangerTable ( RatioTapChangerTable ratioTapChangerTable ) { this.ratioTapChangerTable = ratioTapChangerTable; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RatioTapChangerTable\"")
        private RatioTapChangerTable ratioTapChangerTable ;
         
        /**
         * Transformer end to which this ratio tap changer belongs.
         */
        public TransformerEnd getTransformerEnd () { return transformerEnd; }
        public void setTransformerEnd ( TransformerEnd transformerEnd ) { this.transformerEnd = transformerEnd; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TransformerEnd\"")
        private TransformerEnd transformerEnd ;
         
    }
    /**
     * Describes a curve for how the voltage magnitude and impedance varies with
     * the tap step.
     */
    @Entity
    @Table(name="\"RatioTapChangerTable\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RatioTapChangerTable
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Describes a curve for how the voltage magnitude and impedance varies with
     * the tap step.
     */
    @Entity
    @Table(name="\"RatioTapChangerTable1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RatioTapChangerTable1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Describes each tap step in the ratio tap changer tabular curve.
     */
    @Entity
    @Table(name="\"RatioTapChangerTablePoint\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class RatioTapChangerTablePoint extends TapChangerTablePoint
    {
        /**
         * Table of this point.
         */
        public RatioTapChangerTable getRatioTapChangerTable () { return ratioTapChangerTable; }
        public void setRatioTapChangerTable ( RatioTapChangerTable ratioTapChangerTable ) { this.ratioTapChangerTable = ratioTapChangerTable; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RatioTapChangerTable\"")
        private RatioTapChangerTable ratioTapChangerTable ;
         
    }
    /**
     * Reactive power rating envelope versus the synchronous machine's active
     * power, in both the generating and motoring modes. For each active power
     * value there is a corresponding high and low reactive power limit value.
     * Typically there will be a separate curve for each coolant condition, such
     * as hydrogen pressure. The Y1 axis values represent reactive minimum and
     * the Y2 axis values represent reactive maximum.
     */
    @Entity
    @Table(name="\"ReactiveCapabilityCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ReactiveCapabilityCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The machine's coolant temperature (e.g., ambient air or stator circulating
         * water).
         */
        public Double getCoolantTemperature () { return coolantTemperature; }
        public void setCoolantTemperature ( Double coolantTemperature ) { this.coolantTemperature = coolantTemperature; }
        @Basic()
        @Column(name="\"coolantTemperature\"")
        private Double coolantTemperature ;
         
        /**
         * The hydrogen coolant pressure.
         */
        public Double getHydrogenPressure () { return hydrogenPressure; }
        public void setHydrogenPressure ( Double hydrogenPressure ) { this.hydrogenPressure = hydrogenPressure; }
        @Basic()
        @Column(name="\"hydrogenPressure\"")
        private Double hydrogenPressure ;
         
    }
    /**
     * Pole-mounted fault interrupter with built-in phase and ground relays, current
     * transformer (CT), and supplemental controls.
     */
    @Entity
    @Table(name="\"Recloser\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Recloser extends ProtectedSwitch
    {
    }
    /**
     * A type of conducting equipment that can regulate a quantity (i.e. voltage
     * or flow) at a specific point in the network.
     */
    @Entity
    @Table(name="\"RegulatingCondEq\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class RegulatingCondEq extends EnergyConnection
    {
        /**
         * Specifies the regulation status of the equipment. True is regulating, false
         * is not regulating.
         */
        public Boolean getControlEnabled () { return controlEnabled; }
        public void setControlEnabled ( Boolean controlEnabled ) { this.controlEnabled = controlEnabled; }
        @Basic()
        @Column(name="\"controlEnabled\"")
        private Boolean controlEnabled ;
         
        /**
         * The regulating control scheme in which this equipment participates.
         */
        public RegulatingControl getRegulatingControl () { return regulatingControl; }
        public void setRegulatingControl ( RegulatingControl regulatingControl ) { this.regulatingControl = regulatingControl; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RegulatingControl\"")
        private RegulatingControl regulatingControl ;
         
    }
    /**
     * Specifies a set of equipment that works together to control a power system
     * quantity such as voltage or flow.
     * Remote bus voltage control is possible by specifying the controlled terminal
     * located at some place remote from the controlling equipment.
     * The specified terminal shall be associated with the connectivity node of
     * the controlled point. The most specific subtype of RegulatingControl shall
     * be used in case such equipment participate in the control, e.g. TapChangerControl
     * for tap changers.
     * For flow control, load sign convention is used, i.e. positive sign means
     * flow out from a TopologicalNode (bus) into the conducting equipment.
     * The attribute minAllowedTargetValue and maxAllowedTargetValue are required
     * in the following cases:
     * - For a power generating module operated in power factor control mode to
     * specify maximum and minimum power factor values;
     * - Whenever it is necessary to have an off center target voltage for the
     * tap changer regulator. For instance, due to long cables to off shore wind
     * farms and the need to have a simpler setup at the off shore transformer
     * platform, the voltage is controlled from the land at the connection point
     * for the off shore wind farm. Since there usually is a voltage rise along
     * the cable, there is typical and overvoltage of up 3-4 kV compared to the
     * on shore station. Thus in normal operation the tap changer on the on shore
     * station is operated with a target set point, which is in the lower parts
     * of the dead band.
     * The attributes minAllowedTargetValue and maxAllowedTargetValue are not
     * related to the attribute targetDeadband and thus they are not treated as
     * an alternative of the targetDeadband. They are needed due to limitations
     * in the local substation controller. The attribute targetDeadband is used
     * to prevent the power flow from move the tap position in circles (hunting)
     * that is to be used regardless of the attributes minAllowedTargetValue and
     * maxAllowedTargetValue.
     */
    @Entity
    @Table(name="\"RegulatingControl\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RegulatingControl
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Specifies a set of equipment that works together to control a power system
     * quantity such as voltage or flow.
     * Remote bus voltage control is possible by specifying the controlled terminal
     * located at some place remote from the controlling equipment.
     * The specified terminal shall be associated with the connectivity node of
     * the controlled point. The most specific subtype of RegulatingControl shall
     * be used in case such equipment participate in the control, e.g. TapChangerControl
     * for tap changers.
     * For flow control, load sign convention is used, i.e. positive sign means
     * flow out from a TopologicalNode (bus) into the conducting equipment.
     * The attribute minAllowedTargetValue and maxAllowedTargetValue are required
     * in the following cases:
     * - For a power generating module operated in power factor control mode to
     * specify maximum and minimum power factor values;
     * - Whenever it is necessary to have an off center target voltage for the
     * tap changer regulator. For instance, due to long cables to off shore wind
     * farms and the need to have a simpler setup at the off shore transformer
     * platform, the voltage is controlled from the land at the connection point
     * for the off shore wind farm. Since there usually is a voltage rise along
     * the cable, there is typical and overvoltage of up 3-4 kV compared to the
     * on shore station. Thus in normal operation the tap changer on the on shore
     * station is operated with a target set point, which is in the lower parts
     * of the dead band.
     * The attributes minAllowedTargetValue and maxAllowedTargetValue are not
     * related to the attribute targetDeadband and thus they are not treated as
     * an alternative of the targetDeadband. They are needed due to limitations
     * in the local substation controller. The attribute targetDeadband is used
     * to prevent the power flow from move the tap position in circles (hunting)
     * that is to be used regardless of the attributes minAllowedTargetValue and
     * maxAllowedTargetValue.
     */
    @Entity
    @Table(name="\"RegulatingControl1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RegulatingControl1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The regulation is performed in a discrete mode. This applies to equipment
         * with discrete controls, e.g. tap changers and shunt compensators.
         */
        public Boolean getDiscrete () { return discrete; }
        public void setDiscrete ( Boolean discrete ) { this.discrete = discrete; }
        @Basic()
        @Column(name="\"discrete\"")
        private Boolean discrete ;
         
        /**
         * The flag tells if regulation is enabled.
         */
        public Boolean getEnabled () { return enabled; }
        public void setEnabled ( Boolean enabled ) { this.enabled = enabled; }
        @Basic()
        @Column(name="\"enabled\"")
        private Boolean enabled ;
         
        /**
         * Maximum allowed target value (RegulatingControl.targetValue).
         */
        public Double getMaxAllowedTargetValue () { return maxAllowedTargetValue; }
        public void setMaxAllowedTargetValue ( Double maxAllowedTargetValue ) { this.maxAllowedTargetValue = maxAllowedTargetValue; }
        @Basic()
        @Column(name="\"maxAllowedTargetValue\"")
        private Double maxAllowedTargetValue ;
         
        /**
         * Minimum allowed target value (RegulatingControl.targetValue).
         */
        public Double getMinAllowedTargetValue () { return minAllowedTargetValue; }
        public void setMinAllowedTargetValue ( Double minAllowedTargetValue ) { this.minAllowedTargetValue = minAllowedTargetValue; }
        @Basic()
        @Column(name="\"minAllowedTargetValue\"")
        private Double minAllowedTargetValue ;
         
        /**
         * The regulating control mode presently available. This specification allows
         * for determining the kind of regulation without need for obtaining the units
         * from a schedule.
         */
        public String getMode () { return mode; }
        public void setMode ( String mode ) { this.mode = mode; }
        @Basic()
        @Column(name="\"mode\"")
        private String mode ;
         
        /**
         * Phase voltage controlling this regulator, measured at regulator location.
         */
        public String getMonitoredPhase () { return monitoredPhase; }
        public void setMonitoredPhase ( String monitoredPhase ) { this.monitoredPhase = monitoredPhase; }
        @Basic()
        @Column(name="\"monitoredPhase\"")
        private String monitoredPhase ;
         
        /**
         * This is a deadband used with discrete control to avoid excessive update
         * of controls like tap changers and shunt compensator banks while regulating.
         * The units of those appropriate for the mode. The attribute shall be a positive
         * value or zero. If RegulatingControl.discrete is set to "false", the RegulatingControl.targetDeadband
         * is to be ignored.
         * Note that for instance, if the targetValue is 100 kV and the targetDeadband
         * is 2 kV the range is from 99 to 101 kV.
         */
        public Double getTargetDeadband () { return targetDeadband; }
        public void setTargetDeadband ( Double targetDeadband ) { this.targetDeadband = targetDeadband; }
        @Basic()
        @Column(name="\"targetDeadband\"")
        private Double targetDeadband ;
         
        /**
         * The target value specified for case input. This value can be used for the
         * target value without the use of schedules. The value has the units appropriate
         * to the mode attribute.
         */
        public Double getTargetValue () { return targetValue; }
        public void setTargetValue ( Double targetValue ) { this.targetValue = targetValue; }
        @Basic()
        @Column(name="\"targetValue\"")
        private Double targetValue ;
         
        /**
         * Specify the multiplier for used for the targetValue.
         */
        public String getTargetValueUnitMultiplier () { return targetValueUnitMultiplier; }
        public void setTargetValueUnitMultiplier ( String targetValueUnitMultiplier ) { this.targetValueUnitMultiplier = targetValueUnitMultiplier; }
        @Basic()
        @Column(name="\"targetValueUnitMultiplier\"")
        private String targetValueUnitMultiplier ;
         
        /**
         * The terminal associated with this regulating control. The terminal is associated
         * instead of a node, since the terminal could connect into either a topological
         * node or a connectivity node. Sometimes it is useful to model regulation
         * at a terminal of a bus bar object.
         */
        public Terminal getTerminal () { return terminal; }
        public void setTerminal ( Terminal terminal ) { this.terminal = terminal; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Terminal\"")
        private Terminal terminal ;
         
    }
     
    /**
     * The kind of regulation model. For example regulating voltage, reactive
     * power, active power, etc.
     */
    @Entity
    @Table(name="\"RegulatingControlModeKind\"")
    public static class RegulatingControlModeKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The kind of regulation model. For example regulating voltage, reactive
     * power, active power, etc.
     */
    @Entity
    @Table(name="\"RegulatingControlModeKind1\"")
    public static class RegulatingControlModeKind1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A pre-established pattern over time for a controlled variable, e.g., busbar
     * voltage.
     */
    @Entity
    @Table(name="\"RegulationSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RegulationSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Regulating controls that have this schedule.
         */
        public RegulatingControl getRegulatingControl () { return regulatingControl; }
        public void setRegulatingControl ( RegulatingControl regulatingControl ) { this.regulatingControl = regulatingControl; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RegulatingControl\"")
        private RegulatingControl regulatingControl ;
         
    }
    /**
     * A rotating machine which may be used as a generator or motor.
     */
    @Entity
    @Table(name="\"RotatingMachine\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class RotatingMachine extends RegulatingCondEq
    {
        /**
         * Active power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Reactive power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Power factor (nameplate data). It is primarily used for short circuit data
         * exchange according to IEC 60909. The attribute cannot be a negative value.
         */
        public Double getRatedPowerFactor () { return ratedPowerFactor; }
        public void setRatedPowerFactor ( Double ratedPowerFactor ) { this.ratedPowerFactor = ratedPowerFactor; }
        @Basic()
        @Column(name="\"ratedPowerFactor\"")
        private Double ratedPowerFactor ;
         
        /**
         * Nameplate apparent power rating for the unit.
         * The attribute shall have a positive value.
         */
        public Double getRatedS () { return ratedS; }
        public void setRatedS ( Double ratedS ) { this.ratedS = ratedS; }
        @Basic()
        @Column(name="\"ratedS\"")
        private Double ratedS ;
         
        /**
         * Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
         * for short circuit data exchange according to IEC 60909.
         * The attribute shall be a positive value.
         */
        public Double getRatedU () { return ratedU; }
        public void setRatedU ( Double ratedU ) { this.ratedU = ratedU; }
        @Basic()
        @Column(name="\"ratedU\"")
        private Double ratedU ;
         
        /**
         * A synchronous machine may operate as a generator and as such becomes a
         * member of a generating unit.
         */
        public GeneratingUnit getGeneratingUnit () { return generatingUnit; }
        public void setGeneratingUnit ( GeneratingUnit generatingUnit ) { this.generatingUnit = generatingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GeneratingUnit\"")
        private GeneratingUnit generatingUnit ;
         
        /**
         * The synchronous machine drives the turbine which moves the water from a
         * low elevation to a higher elevation. The direction of machine rotation
         * for pumping may or may not be the same as for generating.
         */
        public HydroPump getHydroPump () { return hydroPump; }
        public void setHydroPump ( HydroPump hydroPump ) { this.hydroPump = hydroPump; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroPump\"")
        private HydroPump hydroPump ;
         
    }
     
    /**
     * Static VAr Compensator control mode.
     */
    @Entity
    @Table(name="\"SVCControlMode\"")
    public static class SVCControlMode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Automatic switch that will lock open to isolate a faulted section. It may,
     * or may not, have load breaking capability. Its primary purpose is to provide
     * fault sectionalising at locations where the fault current is either too
     * high, or too low, for proper coordination of fuses.
     */
    @Entity
    @Table(name="\"Sectionaliser\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class Sectionaliser extends Switch
    {
    }
    /**
     * A Series Compensator is a series capacitor or reactor or an AC transmission
     * line without charging susceptance. It is a two terminal device.
     */
    @Entity
    @Table(name="\"SeriesCompensator\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SeriesCompensator
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Positive sequence resistance.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence resistance.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Describe if a metal oxide varistor (mov) for over voltage protection is
         * configured in parallel with the series compensator. It is used for short
         * circuit calculations.
         */
        public Boolean getVaristorPresent () { return varistorPresent; }
        public void setVaristorPresent ( Boolean varistorPresent ) { this.varistorPresent = varistorPresent; }
        @Basic()
        @Column(name="\"varistorPresent\"")
        private Boolean varistorPresent ;
         
        /**
         * The maximum current the varistor is designed to handle at specified duration.
         * It is used for short circuit calculations and exchanged only if SeriesCompensator.varistorPresent
         * is true.
         * The attribute shall be a positive value.
         */
        public Double getVaristorRatedCurrent () { return varistorRatedCurrent; }
        public void setVaristorRatedCurrent ( Double varistorRatedCurrent ) { this.varistorRatedCurrent = varistorRatedCurrent; }
        @Basic()
        @Column(name="\"varistorRatedCurrent\"")
        private Double varistorRatedCurrent ;
         
        /**
         * The dc voltage at which the varistor starts conducting. It is used for
         * short circuit calculations and exchanged only if SeriesCompensator.varistorPresent
         * is true.
         */
        public Double getVaristorVoltageThreshold () { return varistorVoltageThreshold; }
        public void setVaristorVoltageThreshold ( Double varistorVoltageThreshold ) { this.varistorVoltageThreshold = varistorVoltageThreshold; }
        @Basic()
        @Column(name="\"varistorVoltageThreshold\"")
        private Double varistorVoltageThreshold ;
         
        /**
         * Positive sequence reactance.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero sequence reactance.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
    }
     
    /**
     * Type of rotor, used by short circuit applications.
     */
    @Entity
    @Table(name="\"ShortCircuitRotorKind\"")
    public static class ShortCircuitRotorKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A shunt capacitor or reactor or switchable bank of shunt capacitors or
     * reactors. A section of a shunt compensator is an individual capacitor or
     * reactor. A negative value for bPerSection indicates that the compensator
     * is a reactor. ShuntCompensator is a single terminal device. Ground is implied.
     */
    @Entity
    @Table(name="\"ShuntCompensator\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class ShuntCompensator extends RegulatingCondEq
    {
        /**
         * An automatic voltage regulation delay (AVRDelay) which is the time delay
         * from a change in voltage to when the capacitor is allowed to change state.
         * This filters out temporary changes in voltage.
         */
        public Double getAVRDelay () { return aVRDelay; }
        public void setAVRDelay ( Double aVRDelay ) { this.aVRDelay = aVRDelay; }
        @Basic()
        @Column(name="\"aVRDelay\"")
        private Double aVRDelay ;
         
        /**
         * Used for Yn and Zn connections. True if the neutral is solidly grounded.
         */
        public Boolean getGrounded () { return grounded; }
        public void setGrounded ( Boolean grounded ) { this.grounded = grounded; }
        @Basic()
        @Column(name="\"grounded\"")
        private Boolean grounded ;
         
        /**
         * The maximum number of sections that may be switched in.
         */
        public Integer getMaximumSections () { return maximumSections; }
        public void setMaximumSections ( Integer maximumSections ) { this.maximumSections = maximumSections; }
        @Basic()
        @Column(name="\"maximumSections\"")
        private Integer maximumSections ;
         
        /**
         * The voltage at which the nominal reactive power may be calculated. This
         * should normally be within 10% of the voltage at which the capacitor is
         * connected to the network.
         */
        public Double getNomU () { return nomU; }
        public void setNomU ( Double nomU ) { this.nomU = nomU; }
        @Basic()
        @Column(name="\"nomU\"")
        private Double nomU ;
         
        /**
         * The normal number of sections switched in. The value shall be between zero
         * and ShuntCompensator.maximumSections.
         */
        public Integer getNormalSections () { return normalSections; }
        public void setNormalSections ( Integer normalSections ) { this.normalSections = normalSections; }
        @Basic()
        @Column(name="\"normalSections\"")
        private Integer normalSections ;
         
        /**
         * The type of phase connection, such as wye or delta.
         */
        public String getPhaseConnection () { return phaseConnection; }
        public void setPhaseConnection ( String phaseConnection ) { this.phaseConnection = phaseConnection; }
        @Basic()
        @Column(name="\"phaseConnection\"")
        private String phaseConnection ;
         
        /**
         * Shunt compensator sections in use. Starting value for steady state solution.
         * The attribute shall be a positive value or zero. Non integer values are
         * allowed to support continuous variables. The reasons for continuous value
         * are to support study cases where no discrete shunt compensators has yet
         * been designed, a solutions where a narrow voltage band force the sections
         * to oscillate or accommodate for a continuous solution as input.
         * For LinearShuntConpensator the value shall be between zero and ShuntCompensator.maximumSections.
         * At value zero the shunt compensator conductance and admittance is zero.
         * Linear interpolation of conductance and admittance between the previous
         * and next integer section is applied in case of non-integer values.
         * For NonlinearShuntCompensator-s shall only be set to one of the NonlinearShuntCompenstorPoint.sectionNumber.
         * There is no interpolation between NonlinearShuntCompenstorPoint-s.
         */
        public Double getSections () { return sections; }
        public void setSections ( Double sections ) { this.sections = sections; }
        @Basic()
        @Column(name="\"sections\"")
        private Double sections ;
         
        /**
         * The switch on count since the capacitor count was last reset or initialized.
         */
        public Integer getSwitchOnCount () { return switchOnCount; }
        public void setSwitchOnCount ( Integer switchOnCount ) { this.switchOnCount = switchOnCount; }
        @Basic()
        @Column(name="\"switchOnCount\"")
        private Integer switchOnCount ;
         
        /**
         * The date and time when the capacitor bank was last switched on.
         */
        public String getSwitchOnDate () { return switchOnDate; }
        public void setSwitchOnDate ( String switchOnDate ) { this.switchOnDate = switchOnDate; }
        @Basic()
        @Column(name="\"switchOnDate\"")
        private String switchOnDate ;
         
        /**
         * Voltage sensitivity required for the device to regulate the bus voltage,
         * in voltage/reactive power.
         */
        public Double getVoltageSensitivity () { return voltageSensitivity; }
        public void setVoltageSensitivity ( Double voltageSensitivity ) { this.voltageSensitivity = voltageSensitivity; }
        @Basic()
        @Column(name="\"voltageSensitivity\"")
        private Double voltageSensitivity ;
         
        /**
         * The shunt compensator action that is performed on the shunt compensator
         */
        public ShuntCompensatorAction getShuntCompensatorAction () { return shuntCompensatorAction; }
        public void setShuntCompensatorAction ( ShuntCompensatorAction shuntCompensatorAction ) { this.shuntCompensatorAction = shuntCompensatorAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ShuntCompensatorAction\"")
        private ShuntCompensatorAction shuntCompensatorAction ;
         
    }
    /**
     */
    @Entity
    @Table(name="\"ShuntCompensatorAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ShuntCompensatorAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Single phase of a multi-phase shunt compensator when its attributes might
     * be different per phase.
     */
    @Entity
    @Table(name="\"ShuntCompensatorPhase\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ShuntCompensatorPhase
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The maximum number of sections that may be switched in for this phase.
         */
        public Integer getMaximumSections () { return maximumSections; }
        public void setMaximumSections ( Integer maximumSections ) { this.maximumSections = maximumSections; }
        @Basic()
        @Column(name="\"maximumSections\"")
        private Integer maximumSections ;
         
        /**
         * For the capacitor phase, the normal number of sections switched in. The
         * value shall be between zero and ShuntCompensatorPhase.maximumSections.
         */
        public Integer getNormalSections () { return normalSections; }
        public void setNormalSections ( Integer normalSections ) { this.normalSections = normalSections; }
        @Basic()
        @Column(name="\"normalSections\"")
        private Integer normalSections ;
         
        /**
         * Phase of this shunt compensator component. If the shunt compensator is
         * wye connected, the connection is from the indicated phase to the central
         * ground or neutral point. If the shunt compensator is delta connected, the
         * phase indicates a shunt compensator connected from the indicated phase
         * to the next logical non-neutral phase.
         */
        public String getPhase () { return phase; }
        public void setPhase ( String phase ) { this.phase = phase; }
        @Basic()
        @Column(name="\"phase\"")
        private String phase ;
         
        /**
         * Shunt compensator sections in use. Starting value for steady state solution.
         * The attribute shall be a positive value or zero. Non integer values are
         * allowed to support continuous variables. The reasons for continuous value
         * are to support study cases where no discrete shunt compensators has yet
         * been designed, a solutions where a narrow voltage band force the sections
         * to oscillate or accommodate for a continuous solution as input.
         * For LinearShuntConpensator the value shall be between zero and ShuntCompensatorPhase.maximumSections.
         * At value zero the shunt compensator conductance and admittance is zero.
         * Linear interpolation of conductance and admittance between the previous
         * and next integer section is applied in case of non-integer values.
         * For NonlinearShuntCompensator-s shall only be set to one of the NonlinearShuntCompenstorPhasePoint.sectionNumber.
         * There is no interpolation between NonlinearShuntCompenstorPhasePoint-s.
         */
        public Double getSections () { return sections; }
        public void setSections ( Double sections ) { this.sections = sections; }
        @Basic()
        @Column(name="\"sections\"")
        private Double sections ;
         
        /**
         * Shunt compensator of this shunt compensator phase.
         */
        public ShuntCompensator getShuntCompensator () { return shuntCompensator; }
        public void setShuntCompensator ( ShuntCompensator shuntCompensator ) { this.shuntCompensator = shuntCompensator; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ShuntCompensator\"")
        private ShuntCompensator shuntCompensator ;
         
    }
     
    /**
     * Enumeration of single phase identifiers. Allows designation of single phases
     * for both transmission and distribution equipment, circuits and loads.
     */
    @Entity
    @Table(name="\"SinglePhaseKind\"")
    public static class SinglePhaseKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Enumeration of single phase identifiers. Allows designation of single phases
     * for both transmission and distribution equipment, circuits and loads.
     */
    @Entity
    @Table(name="\"SinglePhaseKind1\"")
    public static class SinglePhaseKind1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A facility for providing variable and controllable shunt reactive power.
     * The SVC typically consists of a stepdown transformer, filter, thyristor-controlled
     * reactor, and thyristor-switched capacitor arms.
     * The SVC may operate in fixed MVar output mode or in voltage control mode.
     * When in voltage control mode, the output of the SVC will be proportional
     * to the deviation of voltage at the controlled bus from the voltage setpoint.
     * The SVC characteristic slope defines the proportion. If the voltage at
     * the controlled bus is equal to the voltage setpoint, the SVC MVar output
     * is zero.
     */
    @Entity
    @Table(name="\"StaticVarCompensator\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class StaticVarCompensator extends RegulatingCondEq
    {
        /**
         * Capacitive reactance at maximum capacitive reactive power. Shall always
         * be positive.
         */
        public Double getCapacitiveRating () { return capacitiveRating; }
        public void setCapacitiveRating ( Double capacitiveRating ) { this.capacitiveRating = capacitiveRating; }
        @Basic()
        @Column(name="\"capacitiveRating\"")
        private Double capacitiveRating ;
         
        /**
         * Inductive reactance at maximum inductive reactive power. Shall always be
         * negative.
         */
        public Double getInductiveRating () { return inductiveRating; }
        public void setInductiveRating ( Double inductiveRating ) { this.inductiveRating = inductiveRating; }
        @Basic()
        @Column(name="\"inductiveRating\"")
        private Double inductiveRating ;
         
        /**
         * Reactive power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * The characteristics slope of an SVC defines how the reactive power output
         * changes in proportion to the difference between the regulated bus voltage
         * and the voltage setpoint.
         * The attribute shall be a positive value or zero.
         */
        public Double getSlope () { return slope; }
        public void setSlope ( Double slope ) { this.slope = slope; }
        @Basic()
        @Column(name="\"slope\"")
        private Double slope ;
         
        /**
         * SVC control mode.
         */
        public String getSVCControlMode () { return sVCControlMode; }
        public void setSVCControlMode ( String sVCControlMode ) { this.sVCControlMode = sVCControlMode; }
        @Basic()
        @Column(name="\"sVCControlMode\"")
        private String sVCControlMode ;
         
        /**
         * The reactive power output of the SVC is proportional to the difference
         * between the voltage at the regulated bus and the voltage setpoint. When
         * the regulated bus voltage is equal to the voltage setpoint, the reactive
         * power output is zero.
         */
        public Double getVoltageSetPoint () { return voltageSetPoint; }
        public void setVoltageSetPoint ( Double voltageSetPoint ) { this.voltageSetPoint = voltageSetPoint; }
        @Basic()
        @Column(name="\"voltageSetPoint\"")
        private Double voltageSetPoint ;
         
        /**
         * Static Var Compensator dynamics model used to describe dynamic behaviour
         * of this Static Var Compensator.
         */
        public StaticVarCompensatorDynamics getStaticVarCompensatorDynamics () { return staticVarCompensatorDynamics; }
        public void setStaticVarCompensatorDynamics ( StaticVarCompensatorDynamics staticVarCompensatorDynamics ) { this.staticVarCompensatorDynamics = staticVarCompensatorDynamics; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StaticVarCompensatorDynamics\"")
        private StaticVarCompensatorDynamics staticVarCompensatorDynamics ;
         
    }
    /**
     * Static var compensator whose behaviour is described by reference to a standard
     * model <font color="#0f0f0f">or by definition of a user-defined model.</font>
     */
    @Entity
    @Table(name="\"StaticVarCompensatorDynamics\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class StaticVarCompensatorDynamics
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A subset of a geographical region of a power system network model.
     */
    @Entity
    @Table(name="\"SubGeographicalRegion\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SubGeographicalRegion
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * State variable for transformer tap step.
     */
    @Entity
    @Table(name="\"SvTapStep\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SvTapStep
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A generic device designed to close, or open, or both, one or more electric
     * circuits. All switches are two terminal devices including grounding switches.
     * The ACDCTerminal.connected at the two sides of the switch shall not be
     * considered for assessing switch connectivity, i.e. only Switch.open, .normalOpen
     * and .locked are relevant.
     */
    @Entity
    @Table(name="\"Switch\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Switch
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A generic device designed to close, or open, or both, one or more electric
     * circuits. All switches are two terminal devices including grounding switches.
     * The ACDCTerminal.connected at the two sides of the switch shall not be
     * considered for assessing switch connectivity, i.e. only Switch.open, .normalOpen
     * and .locked are relevant.
     */
    @Entity
    @Table(name="\"Switch1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Switch1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * If true, the switch is locked. The resulting switch state is a combination
         * of locked and Switch.open attributes as follows:
         * <ul>
         * <li>locked=true and Switch.open=true. The resulting state is open and locked;</li>
         * <li>locked=false and Switch.open=true. The resulting state is open;</li>
         * <li>locked=false and Switch.open=false. The resulting state is closed.</li>
         * </ul>
         */
        public Boolean getLocked () { return locked; }
        public void setLocked ( Boolean locked ) { this.locked = locked; }
        @Basic()
        @Column(name="\"locked\"")
        private Boolean locked ;
         
        /**
         * The attribute is used in cases when no Measurement for the status value
         * is present. If the Switch has a status measurement the Discrete.normalValue
         * is expected to match with the Switch.normalOpen.
         */
        public Boolean getNormalOpen () { return normalOpen; }
        public void setNormalOpen ( Boolean normalOpen ) { this.normalOpen = normalOpen; }
        @Basic()
        @Column(name="\"normalOpen\"")
        private Boolean normalOpen ;
         
        /**
         * The attribute tells if the switch is considered open when used as input
         * to topology processing.
         */
        public Boolean getOpen () { return open; }
        public void setOpen ( Boolean open ) { this.open = open; }
        @Basic()
        @Column(name="\"open\"")
        private Boolean open ;
         
        /**
         * The maximum continuous current carrying capacity in amps governed by the
         * device material and construction.
         * The attribute shall be a positive value.
         */
        public Double getRatedCurrent () { return ratedCurrent; }
        public void setRatedCurrent ( Double ratedCurrent ) { this.ratedCurrent = ratedCurrent; }
        @Basic()
        @Column(name="\"ratedCurrent\"")
        private Double ratedCurrent ;
         
        /**
         * Branch is retained in the topological solution. The flow through retained
         * switches will normally be calculated in power flow.
         */
        public Boolean getRetained () { return retained; }
        public void setRetained ( Boolean retained ) { this.retained = retained; }
        @Basic()
        @Column(name="\"retained\"")
        private Boolean retained ;
         
        /**
         * The switch on count since the switch was last reset or initialized.
         */
        public Integer getSwitchOnCount () { return switchOnCount; }
        public void setSwitchOnCount ( Integer switchOnCount ) { this.switchOnCount = switchOnCount; }
        @Basic()
        @Column(name="\"switchOnCount\"")
        private Integer switchOnCount ;
         
        /**
         * The date and time when the switch was last switched on.
         */
        public String getSwitchOnDate () { return switchOnDate; }
        public void setSwitchOnDate ( String switchOnDate ) { this.switchOnDate = switchOnDate; }
        @Basic()
        @Column(name="\"switchOnDate\"")
        private String switchOnDate ;
         
        /**
         * Composite switch to which this Switch belongs.
         */
        public CompositeSwitch getCompositeSwitch () { return compositeSwitch; }
        public void setCompositeSwitch ( CompositeSwitch compositeSwitch ) { this.compositeSwitch = compositeSwitch; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CompositeSwitch\"")
        private CompositeSwitch compositeSwitch ;
         
        /**
         * Action changing status of this switch.
         */
        public SwitchAction getSwitchAction () { return switchAction; }
        public void setSwitchAction ( SwitchAction switchAction ) { this.switchAction = switchAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SwitchAction\"")
        private SwitchAction switchAction ;
         
    }
    /**
     * Action on switch as a switching step.
     */
    @Entity
    @Table(name="\"SwitchAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Single phase of a multi-phase switch when its attributes might be different
     * per phase.
     */
    @Entity
    @Table(name="\"SwitchPhase\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchPhase
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The attribute tells if the switch is considered closed when used as input
         * to topology processing.
         */
        public Boolean getClosed () { return closed; }
        public void setClosed ( Boolean closed ) { this.closed = closed; }
        @Basic()
        @Column(name="\"closed\"")
        private Boolean closed ;
         
        /**
         * Used in cases when no Measurement for the status value is present. If the
         * SwitchPhase has a status measurement the Discrete.normalValue is expected
         * to match with this value.
         */
        public Boolean getNormalOpen () { return normalOpen; }
        public void setNormalOpen ( Boolean normalOpen ) { this.normalOpen = normalOpen; }
        @Basic()
        @Column(name="\"normalOpen\"")
        private Boolean normalOpen ;
         
        /**
         * Phase of this SwitchPhase on the side with terminal sequence number equal
         * to 1. Should be a phase contained in that terminals phases attribute.
         */
        public String getPhaseSide1 () { return phaseSide1; }
        public void setPhaseSide1 ( String phaseSide1 ) { this.phaseSide1 = phaseSide1; }
        @Basic()
        @Column(name="\"phaseSide1\"")
        private String phaseSide1 ;
         
        /**
         * Phase of this SwitchPhase on the side with terminal sequence number equal
         * to 2. Should be a phase contained in that terminals Terminal.phases attribute.
         */
        public String getPhaseSide2 () { return phaseSide2; }
        public void setPhaseSide2 ( String phaseSide2 ) { this.phaseSide2 = phaseSide2; }
        @Basic()
        @Column(name="\"phaseSide2\"")
        private String phaseSide2 ;
         
        /**
         * The maximum continuous current carrying capacity in amps governed by the
         * device material and construction.
         * The attribute shall be a positive value.
         */
        public Double getRatedCurrent () { return ratedCurrent; }
        public void setRatedCurrent ( Double ratedCurrent ) { this.ratedCurrent = ratedCurrent; }
        @Basic()
        @Column(name="\"ratedCurrent\"")
        private Double ratedCurrent ;
         
        /**
         * The switch of the switch phase.
         */
        public Switch getSwitch () { return switch; }
        public void setSwitch ( Switch switch ) { this.switch = switch; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Switch\"")
        private Switch switch ;
         
    }
    /**
     * A schedule of switch positions. If RegularTimePoint.value1 is 0, the switch
     * is open. If 1, the switch is closed.
     */
    @Entity
    @Table(name="\"SwitchSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A schedule of switch positions. If RegularTimePoint.value1 is 0, the switch
     * is open. If 1, the switch is closed.
     */
    @Entity
    @Table(name="\"SwitchSchedule1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SwitchSchedule1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A SwitchSchedule is associated with a Switch.
         */
        public Switch getSwitch () { return switch; }
        public void setSwitch ( Switch switch ) { this.switch = switch; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Switch\"")
        private Switch switch ;
         
    }
    /**
     * An electromechanical device that operates with shaft rotating synchronously
     * with the network. It is a single machine operating either as a generator
     * or synchronous condenser or pump.
     */
    @Entity
    @Table(name="\"SynchronousMachine\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class SynchronousMachine extends RotatingMachine
    {
        /**
         * Time delay required when switching from Automatic Voltage Regulation (AVR)
         * to Manual for a lagging MVAr violation.
         */
        public Double getAVRToManualLag () { return aVRToManualLag; }
        public void setAVRToManualLag ( Double aVRToManualLag ) { this.aVRToManualLag = aVRToManualLag; }
        @Basic()
        @Column(name="\"aVRToManualLag\"")
        private Double aVRToManualLag ;
         
        /**
         * Time delay required when switching from Automatic Voltage Regulation (AVR)
         * to Manual for a leading MVAr violation.
         */
        public Double getAVRToManualLead () { return aVRToManualLead; }
        public void setAVRToManualLead ( Double aVRToManualLead ) { this.aVRToManualLead = aVRToManualLead; }
        @Basic()
        @Column(name="\"aVRToManualLead\"")
        private Double aVRToManualLead ;
         
        /**
         * Default base reactive power value. This value represents the initial reactive
         * power that can be used by any application function.
         */
        public Double getBaseQ () { return baseQ; }
        public void setBaseQ ( Double baseQ ) { this.baseQ = baseQ; }
        @Basic()
        @Column(name="\"baseQ\"")
        private Double baseQ ;
         
        /**
         * Active power consumed when in condenser mode operation.
         */
        public Double getCondenserP () { return condenserP; }
        public void setCondenserP ( Double condenserP ) { this.condenserP = condenserP; }
        @Basic()
        @Column(name="\"condenserP\"")
        private Double condenserP ;
         
        /**
         * Temperature or pressure of coolant medium.
         */
        public Double getCoolantCondition () { return coolantCondition; }
        public void setCoolantCondition ( Double coolantCondition ) { this.coolantCondition = coolantCondition; }
        @Basic()
        @Column(name="\"coolantCondition\"")
        private Double coolantCondition ;
         
        /**
         * Method of cooling the machine.
         */
        public String getCoolantType () { return coolantType; }
        public void setCoolantType ( String coolantType ) { this.coolantType = coolantType; }
        @Basic()
        @Column(name="\"coolantType\"")
        private String coolantType ;
         
        /**
         * Indicates whether or not the generator is earthed. Used for short circuit
         * data exchange according to IEC 60909.
         */
        public Boolean getEarthing () { return earthing; }
        public void setEarthing ( Boolean earthing ) { this.earthing = earthing; }
        @Basic()
        @Column(name="\"earthing\"")
        private Boolean earthing ;
         
        /**
         * Generator star point earthing resistance (Re). Used for short circuit data
         * exchange according to IEC 60909.
         */
        public Double getEarthingStarPointR () { return earthingStarPointR; }
        public void setEarthingStarPointR ( Double earthingStarPointR ) { this.earthingStarPointR = earthingStarPointR; }
        @Basic()
        @Column(name="\"earthingStarPointR\"")
        private Double earthingStarPointR ;
         
        /**
         * Generator star point earthing reactance (Xe). Used for short circuit data
         * exchange according to IEC 60909.
         */
        public Double getEarthingStarPointX () { return earthingStarPointX; }
        public void setEarthingStarPointX ( Double earthingStarPointX ) { this.earthingStarPointX = earthingStarPointX; }
        @Basic()
        @Column(name="\"earthingStarPointX\"")
        private Double earthingStarPointX ;
         
        /**
         * Steady-state short-circuit current (in A for the profile) of generator
         * with compound excitation during 3-phase short circuit.
         * - Ikk=0: Generator with no compound excitation.
         * - Ikk&lt;&gt;0: Generator with compound excitation.
         * Ikk is used to calculate the minimum steady-state short-circuit current
         * for generators with compound excitation.
         * (4.6.1.2 in IEC 60909-0:2001).
         * Used only for single fed short circuit on a generator. (4.3.4.2. in IEC
         * 60909-0:2001).
         */
        public Double getIkk () { return ikk; }
        public void setIkk ( Double ikk ) { this.ikk = ikk; }
        @Basic()
        @Column(name="\"ikk\"")
        private Double ikk ;
         
        /**
         * Time delay required when switching from Manual to Automatic Voltage Regulation.
         * This value is used in the accelerating power reference frame for powerflow
         * solutions.
         */
        public Double getManualToAVR () { return manualToAVR; }
        public void setManualToAVR ( Double manualToAVR ) { this.manualToAVR = manualToAVR; }
        @Basic()
        @Column(name="\"manualToAVR\"")
        private Double manualToAVR ;
         
        /**
         * Maximum reactive power limit. This is the maximum (nameplate) limit for
         * the unit.
         */
        public Double getMaxQ () { return maxQ; }
        public void setMaxQ ( Double maxQ ) { this.maxQ = maxQ; }
        @Basic()
        @Column(name="\"maxQ\"")
        private Double maxQ ;
         
        /**
         * Maximum voltage limit for the unit.
         */
        public Double getMaxU () { return maxU; }
        public void setMaxU ( Double maxU ) { this.maxU = maxU; }
        @Basic()
        @Column(name="\"maxU\"")
        private Double maxU ;
         
        /**
         * Minimum reactive power limit for the unit.
         */
        public Double getMinQ () { return minQ; }
        public void setMinQ ( Double minQ ) { this.minQ = minQ; }
        @Basic()
        @Column(name="\"minQ\"")
        private Double minQ ;
         
        /**
         * Minimum voltage limit for the unit.
         */
        public Double getMinU () { return minU; }
        public void setMinU ( Double minU ) { this.minU = minU; }
        @Basic()
        @Column(name="\"minU\"")
        private Double minU ;
         
        /**
         * Factor to calculate the breaking current (Section 4.5.2.1 in IEC 60909-0).
         * Used only for single fed short circuit on a generator (Section 4.3.4.2.
         * in IEC 60909-0).
         */
        public Double getMu () { return mu; }
        public void setMu ( Double mu ) { this.mu = mu; }
        @Basic()
        @Column(name="\"mu\"")
        private Double mu ;
         
        /**
         * Current mode of operation.
         */
        public String getOperatingMode () { return operatingMode; }
        public void setOperatingMode ( String operatingMode ) { this.operatingMode = operatingMode; }
        @Basic()
        @Column(name="\"operatingMode\"")
        private String operatingMode ;
         
        /**
         * Part of the coordinated reactive control that comes from this machine.
         * The attribute is used as a participation factor not necessarily summing
         * up to 100% for the participating devices in the control.
         */
        public Double getQPercent () { return qPercent; }
        public void setQPercent ( Double qPercent ) { this.qPercent = qPercent; }
        @Basic()
        @Column(name="\"qPercent\"")
        private Double qPercent ;
         
        /**
         * Equivalent resistance (RG) of generator. RG is considered for the calculation
         * of all currents, except for the calculation of the peak current ip. Used
         * for short circuit data exchange according to IEC 60909.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence resistance of the synchronous machine.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Negative sequence resistance.
         */
        public Double getR2 () { return r2; }
        public void setR2 ( Double r2 ) { this.r2 = r2; }
        @Basic()
        @Column(name="\"r2\"")
        private Double r2 ;
         
        /**
         * Priority of unit for use as powerflow voltage phase angle reference bus
         * selection. 0 = don t care (default) 1 = highest priority. 2 is less than
         * 1 and so on.
         */
        public Integer getReferencePriority () { return referencePriority; }
        public void setReferencePriority ( Integer referencePriority ) { this.referencePriority = referencePriority; }
        @Basic()
        @Column(name="\"referencePriority\"")
        private Integer referencePriority ;
         
        /**
         * Direct-axis subtransient reactance saturated, also known as Xd"sat.
         */
        public Double getSatDirectSubtransX () { return satDirectSubtransX; }
        public void setSatDirectSubtransX ( Double satDirectSubtransX ) { this.satDirectSubtransX = satDirectSubtransX; }
        @Basic()
        @Column(name="\"satDirectSubtransX\"")
        private Double satDirectSubtransX ;
         
        /**
         * Direct-axes saturated synchronous reactance (xdsat); reciprocal of short-circuit
         * ration. Used for short circuit data exchange, only for single fed short
         * circuit on a generator. (4.3.4.2. in IEC 60909-0:2001).
         */
        public Double getSatDirectSyncX () { return satDirectSyncX; }
        public void setSatDirectSyncX ( Double satDirectSyncX ) { this.satDirectSyncX = satDirectSyncX; }
        @Basic()
        @Column(name="\"satDirectSyncX\"")
        private Double satDirectSyncX ;
         
        /**
         * Saturated Direct-axis transient reactance. The attribute is primarily used
         * for short circuit calculations according to ANSI.
         */
        public Double getSatDirectTransX () { return satDirectTransX; }
        public void setSatDirectTransX ( Double satDirectTransX ) { this.satDirectTransX = satDirectTransX; }
        @Basic()
        @Column(name="\"satDirectTransX\"")
        private Double satDirectTransX ;
         
        /**
         * Type of rotor, used by short circuit applications, only for single fed
         * short circuit according to IEC 60909.
         */
        public String getShortCircuitRotorType () { return shortCircuitRotorType; }
        public void setShortCircuitRotorType ( String shortCircuitRotorType ) { this.shortCircuitRotorType = shortCircuitRotorType; }
        @Basic()
        @Column(name="\"shortCircuitRotorType\"")
        private String shortCircuitRotorType ;
         
        /**
         * Modes that this synchronous machine can operate in.
         */
        public String getType () { return type; }
        public void setType ( String type ) { this.type = type; }
        @Basic()
        @Column(name="\"type\"")
        private String type ;
         
        /**
         * Range of generator voltage regulation (PG in IEC 60909-0) used for calculation
         * of the impedance correction factor KG defined in IEC 60909-0.
         * This attribute is used to describe the operating voltage of the generating
         * unit.
         */
        public Double getVoltageRegulationRange () { return voltageRegulationRange; }
        public void setVoltageRegulationRange ( Double voltageRegulationRange ) { this.voltageRegulationRange = voltageRegulationRange; }
        @Basic()
        @Column(name="\"voltageRegulationRange\"")
        private Double voltageRegulationRange ;
         
        /**
         * Zero sequence reactance of the synchronous machine.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * Negative sequence reactance.
         */
        public Double getX2 () { return x2; }
        public void setX2 ( Double x2 ) { this.x2 = x2; }
        @Basic()
        @Column(name="\"x2\"")
        private Double x2 ;
         
        /**
         * The default reactive capability curve for use by a synchronous machine.
         */
        public ReactiveCapabilityCurve getInitialReactiveCapabilityCurve () { return initialReactiveCapabilityCurve; }
        public void setInitialReactiveCapabilityCurve ( ReactiveCapabilityCurve initialReactiveCapabilityCurve ) { this.initialReactiveCapabilityCurve = initialReactiveCapabilityCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"InitialReactiveCapabilityCurve\"")
        private ReactiveCapabilityCurve initialReactiveCapabilityCurve ;
         
        /**
         * Synchronous machine dynamics model used to describe dynamic behaviour of
         * this synchronous machine.
         */
        public SynchronousMachineDynamics getSynchronousMachineDynamics () { return synchronousMachineDynamics; }
        public void setSynchronousMachineDynamics ( SynchronousMachineDynamics synchronousMachineDynamics ) { this.synchronousMachineDynamics = synchronousMachineDynamics; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SynchronousMachineDynamics\"")
        private SynchronousMachineDynamics synchronousMachineDynamics ;
         
    }
    /**
     * Synchronous machine whose behaviour is described by reference to a standard
     * model expressed in one of the following forms:
     * - simplified (or classical), where a group of generators or motors is not
     * modelled in detail;
     * - detailed, in equivalent circuit form;
     * - detailed, in time constant reactance form; or
     * <font color="#0f0f0f">- by definition of a user-defined model.</font>
     * <font color="#0f0f0f">It is a common practice to represent small generators
     * by a negative load rather than by a dynamic generator model when performing
     * dynamics simulations. In this case, a SynchronousMachine in the static
     * model is not represented by anything in the dynamics model, instead it
     * is treated as an ordinary load.</font>
     * <font color="#0f0f0f">Parameter details:</font>
     * <ol>
     * <li><font color="#0f0f0f">Synchronous machine parameters such as <i>Xl,
     * Xd, Xp</i> etc. are actually used as inductances in the models,</font>
     * but are commonly referred to as reactances since, at nominal frequency,
     * the PU values are the same. However, some references use the symbol <i>L</i>
     * instead of <i>X</i>.</li>
     * </ol>
     */
    @Entity
    @Table(name="\"SynchronousMachineDynamics\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SynchronousMachineDynamics
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    /**
     * Synchronous machine type.
     */
    @Entity
    @Table(name="\"SynchronousMachineKind\"")
    public static class SynchronousMachineKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Synchronous machine type.
     */
    @Entity
    @Table(name="\"SynchronousMachineKind1\"")
    public static class SynchronousMachineKind1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Synchronous machine operating mode.
     */
    @Entity
    @Table(name="\"SynchronousMachineOperatingMode\"")
    public static class SynchronousMachineOperatingMode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Synchronous machine operating mode.
     */
    @Entity
    @Table(name="\"SynchronousMachineOperatingMode1\"")
    public static class SynchronousMachineOperatingMode1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Mechanism for changing transformer winding tap positions.
     */
    @Entity
    @Table(name="\"TapChanger\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TapChanger
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Specifies the regulation status of the equipment. True is regulating, false
         * is not regulating.
         */
        public Boolean getControlEnabled () { return controlEnabled; }
        public void setControlEnabled ( Boolean controlEnabled ) { this.controlEnabled = controlEnabled; }
        @Basic()
        @Column(name="\"controlEnabled\"")
        private Boolean controlEnabled ;
         
        /**
         * Highest possible tap step position, advance from neutral.
         * The attribute shall be greater than lowStep.
         */
        public Integer getHighStep () { return highStep; }
        public void setHighStep ( Integer highStep ) { this.highStep = highStep; }
        @Basic()
        @Column(name="\"highStep\"")
        private Integer highStep ;
         
        /**
         * For an LTC, the delay for initial tap changer operation (first step change).
         */
        public Double getInitialDelay () { return initialDelay; }
        public void setInitialDelay ( Double initialDelay ) { this.initialDelay = initialDelay; }
        @Basic()
        @Column(name="\"initialDelay\"")
        private Double initialDelay ;
         
        /**
         * Lowest possible tap step position, retard from neutral.
         */
        public Integer getLowStep () { return lowStep; }
        public void setLowStep ( Integer lowStep ) { this.lowStep = lowStep; }
        @Basic()
        @Column(name="\"lowStep\"")
        private Integer lowStep ;
         
        /**
         * Specifies whether or not a TapChanger has load tap changing capabilities.
         */
        public Boolean getLtcFlag () { return ltcFlag; }
        public void setLtcFlag ( Boolean ltcFlag ) { this.ltcFlag = ltcFlag; }
        @Basic()
        @Column(name="\"ltcFlag\"")
        private Boolean ltcFlag ;
         
        /**
         * The neutral tap step position for this winding.
         * The attribute shall be equal to or greater than lowStep and equal or less
         * than highStep.
         * It is the step position where the voltage is neutralU when the other terminals
         * of the transformer are at the ratedU. If there are other tap changers on
         * the transformer those taps are kept constant at their neutralStep.
         */
        public Integer getNeutralStep () { return neutralStep; }
        public void setNeutralStep ( Integer neutralStep ) { this.neutralStep = neutralStep; }
        @Basic()
        @Column(name="\"neutralStep\"")
        private Integer neutralStep ;
         
        /**
         * Voltage at which the winding operates at the neutral tap setting. It is
         * the voltage at the terminal of the PowerTransformerEnd associated with
         * the tap changer when all tap changers on the transformer are at their neutralStep
         * position. Normally neutralU of the tap changer is the same as ratedU of
         * the PowerTransformerEnd, but it can differ in special cases such as when
         * the tapping mechanism is separate from the winding more common on lower
         * voltage transformers.
         * This attribute is not relevant for PhaseTapChangerAsymmetrical, PhaseTapChangerSymmetrical
         * and PhaseTapChangerLinear.
         */
        public Double getNeutralU () { return neutralU; }
        public void setNeutralU ( Double neutralU ) { this.neutralU = neutralU; }
        @Basic()
        @Column(name="\"neutralU\"")
        private Double neutralU ;
         
        /**
         * The tap step position used in "normal" network operation for this winding.
         * For a "Fixed" tap changer indicates the current physical tap setting.
         * The attribute shall be equal to or greater than lowStep and equal to or
         * less than highStep.
         */
        public Integer getNormalStep () { return normalStep; }
        public void setNormalStep ( Integer normalStep ) { this.normalStep = normalStep; }
        @Basic()
        @Column(name="\"normalStep\"")
        private Integer normalStep ;
         
        /**
         * Tap changer position.
         * Starting step for a steady state solution. Non integer values are allowed
         * to support continuous tap variables. The reasons for continuous value are
         * to support study cases where no discrete tap changer has yet been designed,
         * a solution where a narrow voltage band forces the tap step to oscillate
         * or to accommodate for a continuous solution as input.
         * The attribute shall be equal to or greater than lowStep and equal to or
         * less than highStep.
         */
        public Double getStep () { return step; }
        public void setStep ( Double step ) { this.step = step; }
        @Basic()
        @Column(name="\"step\"")
        private Double step ;
         
        /**
         * For an LTC, the delay for subsequent tap changer operation (second and
         * later step changes).
         */
        public Double getSubsequentDelay () { return subsequentDelay; }
        public void setSubsequentDelay ( Double subsequentDelay ) { this.subsequentDelay = subsequentDelay; }
        @Basic()
        @Column(name="\"subsequentDelay\"")
        private Double subsequentDelay ;
         
        /**
         * The tap step state associated with the tap changer.
         */
        public SvTapStep getSvTapStep () { return svTapStep; }
        public void setSvTapStep ( SvTapStep svTapStep ) { this.svTapStep = svTapStep; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SvTapStep\"")
        private SvTapStep svTapStep ;
         
        /**
         * The regulating control scheme in which this tap changer participates.
         */
        public TapChangerControl getTapChangerControl () { return tapChangerControl; }
        public void setTapChangerControl ( TapChangerControl tapChangerControl ) { this.tapChangerControl = tapChangerControl; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TapChangerControl\"")
        private TapChangerControl tapChangerControl ;
         
    }
    /**
     * Describes behaviour specific to tap changers, e.g. how the voltage at the
     * end of a line varies with the load level and compensation of the voltage
     * drop by tap adjustment.
     */
    @Entity
    @Table(name="\"TapChangerControl\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TapChangerControl
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Describes behaviour specific to tap changers, e.g. how the voltage at the
     * end of a line varies with the load level and compensation of the voltage
     * drop by tap adjustment.
     */
    @Entity
    @Table(name="\"TapChangerControl1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TapChangerControl1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Maximum allowed regulated voltage on the PT secondary, regardless of line
         * drop compensation. Sometimes referred to as first-house protection.
         */
        public Double getLimitVoltage () { return limitVoltage; }
        public void setLimitVoltage ( Double limitVoltage ) { this.limitVoltage = limitVoltage; }
        @Basic()
        @Column(name="\"limitVoltage\"")
        private Double limitVoltage ;
         
        /**
         * If true, the line drop compensation is to be applied.
         */
        public Boolean getLineDropCompensation () { return lineDropCompensation; }
        public void setLineDropCompensation ( Boolean lineDropCompensation ) { this.lineDropCompensation = lineDropCompensation; }
        @Basic()
        @Column(name="\"lineDropCompensation\"")
        private Boolean lineDropCompensation ;
         
        /**
         * Line drop compensator resistance setting for normal (forward) power flow.
         */
        public Double getLineDropR () { return lineDropR; }
        public void setLineDropR ( Double lineDropR ) { this.lineDropR = lineDropR; }
        @Basic()
        @Column(name="\"lineDropR\"")
        private Double lineDropR ;
         
        /**
         * Line drop compensator reactance setting for normal (forward) power flow.
         */
        public Double getLineDropX () { return lineDropX; }
        public void setLineDropX ( Double lineDropX ) { this.lineDropX = lineDropX; }
        @Basic()
        @Column(name="\"lineDropX\"")
        private Double lineDropX ;
         
        /**
         * Line drop compensator resistance setting for reverse power flow.
         */
        public Double getReverseLineDropR () { return reverseLineDropR; }
        public void setReverseLineDropR ( Double reverseLineDropR ) { this.reverseLineDropR = reverseLineDropR; }
        @Basic()
        @Column(name="\"reverseLineDropR\"")
        private Double reverseLineDropR ;
         
        /**
         * Line drop compensator reactance setting for reverse power flow.
         */
        public Double getReverseLineDropX () { return reverseLineDropX; }
        public void setReverseLineDropX ( Double reverseLineDropX ) { this.reverseLineDropX = reverseLineDropX; }
        @Basic()
        @Column(name="\"reverseLineDropX\"")
        private Double reverseLineDropX ;
         
    }
    /**
     * Describes each tap step in the tabular curve.
     */
    @Entity
    @Table(name="\"TapChangerTablePoint\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TapChangerTablePoint
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The magnetizing branch susceptance deviation as a percentage of nominal
         * value. The actual susceptance is calculated as follows:
         * calculated magnetizing susceptance = b(nominal) * (1 + b(from this class)/100).
         * The b(nominal) is defined as the static magnetizing susceptance on the
         * associated power transformer end or ends. This model assumes the star impedance
         * (pi model) form.
         */
        public Double getB () { return b; }
        public void setB ( Double b ) { this.b = b; }
        @Basic()
        @Column(name="\"b\"")
        private Double b ;
         
        /**
         * The magnetizing branch conductance deviation as a percentage of nominal
         * value. The actual conductance is calculated as follows:
         * calculated magnetizing conductance = g(nominal) * (1 + g(from this class)/100).
         * The g(nominal) is defined as the static magnetizing conductance on the
         * associated power transformer end or ends. This model assumes the star impedance
         * (pi model) form.
         */
        public Double getG () { return g; }
        public void setG ( Double g ) { this.g = g; }
        @Basic()
        @Column(name="\"g\"")
        private Double g ;
         
        /**
         * The resistance deviation as a percentage of nominal value. The actual reactance
         * is calculated as follows:
         * calculated resistance = r(nominal) * (1 + r(from this class)/100). The
         * r(nominal) is defined as the static resistance on the associated power
         * transformer end or ends. This model assumes the star impedance (pi model)
         * form.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * The voltage at the tap step divided by rated voltage of the transformer
         * end having the tap changer. Hence this is a value close to one.
         * For example, if the ratio at step 1 is 1.01, and the rated voltage of the
         * transformer end is 110kV, then the voltage obtained by setting the tap
         * changer to step 1 to is 111.1kV.
         */
        public Double getRatio () { return ratio; }
        public void setRatio ( Double ratio ) { this.ratio = ratio; }
        @Basic()
        @Column(name="\"ratio\"")
        private Double ratio ;
         
        /**
         * The tap step.
         */
        public Integer getStep () { return step; }
        public void setStep ( Integer step ) { this.step = step; }
        @Basic()
        @Column(name="\"step\"")
        private Integer step ;
         
        /**
         * The series reactance deviation as a percentage of nominal value. The actual
         * reactance is calculated as follows:
         * calculated reactance = x(nominal) * (1 + x(from this class)/100). The x(nominal)
         * is defined as the static series reactance on the associated power transformer
         * end or ends. This model assumes the star impedance (pi model) form.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
    }
    /**
     * A pre-established pattern over time for a tap step.
     */
    @Entity
    @Table(name="\"TapSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TapSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A TapSchedule is associated with a TapChanger.
         */
        public TapChanger getTapChanger () { return tapChanger; }
        public void setTapChanger ( TapChanger tapChanger ) { this.tapChanger = tapChanger; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TapChanger\"")
        private TapChanger tapChanger ;
         
    }
    /**
     * An AC electrical connection point to a piece of conducting equipment. Terminals
     * are connected at physical connection points called connectivity nodes.
     */
    @Entity
    @Table(name="\"Terminal\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Terminal
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    /**
     * Control modes for a transformer.
     */
    @Entity
    @Table(name="\"TransformerControlMode\"")
    public static class TransformerControlMode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Control modes for a transformer.
     */
    @Entity
    @Table(name="\"TransformerControlMode1\"")
    public static class TransformerControlMode1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * The transformer core admittance. Used to specify the core admittance of
     * a transformer in a manner that can be shared among power transformers.
     */
    @Entity
    @Table(name="\"TransformerCoreAdmittance\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TransformerCoreAdmittance
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Magnetizing branch susceptance (B mag). The value can be positive or negative.
         */
        public Double getB () { return b; }
        public void setB ( Double b ) { this.b = b; }
        @Basic()
        @Column(name="\"b\"")
        private Double b ;
         
        /**
         * Zero sequence magnetizing branch susceptance.
         */
        public Double getB0 () { return b0; }
        public void setB0 ( Double b0 ) { this.b0 = b0; }
        @Basic()
        @Column(name="\"b0\"")
        private Double b0 ;
         
        /**
         * Magnetizing branch conductance (G mag).
         */
        public Double getG () { return g; }
        public void setG ( Double g ) { this.g = g; }
        @Basic()
        @Column(name="\"g\"")
        private Double g ;
         
        /**
         * Zero sequence magnetizing branch conductance.
         */
        public Double getG0 () { return g0; }
        public void setG0 ( Double g0 ) { this.g0 = g0; }
        @Basic()
        @Column(name="\"g0\"")
        private Double g0 ;
         
        /**
         * Transformer end datasheet used to calculate this core admittance.
         */
        public TransformerEndInfo getTransformerEndInfo () { return transformerEndInfo; }
        public void setTransformerEndInfo ( TransformerEndInfo transformerEndInfo ) { this.transformerEndInfo = transformerEndInfo; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TransformerEndInfo\"")
        private TransformerEndInfo transformerEndInfo ;
         
    }
    /**
     * A conducting connection point of a power transformer. It corresponds to
     * a physical transformer winding terminal. In earlier CIM versions, the TransformerWinding
     * class served a similar purpose, but this class is more flexible because
     * it associates to terminal but is not a specialization of ConductingEquipment.
     */
    @Entity
    @Table(name="\"TransformerEnd\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TransformerEnd
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A conducting connection point of a power transformer. It corresponds to
     * a physical transformer winding terminal. In earlier CIM versions, the TransformerWinding
     * class served a similar purpose, but this class is more flexible because
     * it associates to terminal but is not a specialization of ConductingEquipment.
     */
    @Entity
    @Table(name="\"TransformerEnd1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TransformerEnd1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Core shunt magnetizing susceptance in the saturation region.
         */
        public Double getBmagSat () { return bmagSat; }
        public void setBmagSat ( Double bmagSat ) { this.bmagSat = bmagSat; }
        @Basic()
        @Column(name="\"bmagSat\"")
        private Double bmagSat ;
         
        /**
         * Number for this transformer end, corresponding to the end's order in the
         * power transformer vector group or phase angle clock number. Highest voltage
         * winding should be 1. Each end within a power transformer should have a
         * unique subsequent end number. Note the transformer end number need not
         * match the terminal sequence number.
         */
        public Integer getEndNumber () { return endNumber; }
        public void setEndNumber ( Integer endNumber ) { this.endNumber = endNumber; }
        @Basic()
        @Column(name="\"endNumber\"")
        private Integer endNumber ;
         
        /**
         * (for Yn and Zn connections) True if the neutral is solidly grounded.
         */
        public Boolean getGrounded () { return grounded; }
        public void setGrounded ( Boolean grounded ) { this.grounded = grounded; }
        @Basic()
        @Column(name="\"grounded\"")
        private Boolean grounded ;
         
        /**
         * The reference voltage at which the magnetizing saturation measurements
         * were made.
         */
        public Double getMagBaseU () { return magBaseU; }
        public void setMagBaseU ( Double magBaseU ) { this.magBaseU = magBaseU; }
        @Basic()
        @Column(name="\"magBaseU\"")
        private Double magBaseU ;
         
        /**
         * Core magnetizing saturation curve knee flux level.
         */
        public Double getMagSatFlux () { return magSatFlux; }
        public void setMagSatFlux ( Double magSatFlux ) { this.magSatFlux = magSatFlux; }
        @Basic()
        @Column(name="\"magSatFlux\"")
        private Double magSatFlux ;
         
        /**
         * (for Yn and Zn connections) Resistance part of neutral impedance where
         * 'grounded' is true.
         */
        public Double getRground () { return rground; }
        public void setRground ( Double rground ) { this.rground = rground; }
        @Basic()
        @Column(name="\"rground\"")
        private Double rground ;
         
        /**
         * (for Yn and Zn connections) Reactive part of neutral impedance where 'grounded'
         * is true.
         */
        public Double getXground () { return xground; }
        public void setXground ( Double xground ) { this.xground = xground; }
        @Basic()
        @Column(name="\"xground\"")
        private Double xground ;
         
        /**
         * Base voltage of the transformer end. This is essential for PU calculation.
         */
        public BaseVoltage getBaseVoltage () { return baseVoltage; }
        public void setBaseVoltage ( BaseVoltage baseVoltage ) { this.baseVoltage = baseVoltage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"BaseVoltage\"")
        private BaseVoltage baseVoltage ;
         
        /**
         * Core admittance of this transformer end, representing magnetising current
         * and core losses. The full values of the transformer should be supplied
         * for one transformer end only.
         */
        public TransformerCoreAdmittance getCoreAdmittance () { return coreAdmittance; }
        public void setCoreAdmittance ( TransformerCoreAdmittance coreAdmittance ) { this.coreAdmittance = coreAdmittance; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CoreAdmittance\"")
        private TransformerCoreAdmittance coreAdmittance ;
         
        /**
         * Phase tap changer associated with this transformer end.
         */
        public PhaseTapChanger getPhaseTapChanger () { return phaseTapChanger; }
        public void setPhaseTapChanger ( PhaseTapChanger phaseTapChanger ) { this.phaseTapChanger = phaseTapChanger; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PhaseTapChanger\"")
        private PhaseTapChanger phaseTapChanger ;
         
        /**
         * Ratio tap changer associated with this transformer end.
         */
        public RatioTapChanger getRatioTapChanger () { return ratioTapChanger; }
        public void setRatioTapChanger ( RatioTapChanger ratioTapChanger ) { this.ratioTapChanger = ratioTapChanger; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RatioTapChanger\"")
        private RatioTapChanger ratioTapChanger ;
         
        /**
         * (accurate for 2- or 3-winding transformers only) Pi-model impedances of
         * this transformer end. By convention, for a two winding transformer, the
         * full values of the transformer should be entered on the high voltage end
         * (endNumber=1).
         */
        public TransformerStarImpedance getStarImpedance () { return starImpedance; }
        public void setStarImpedance ( TransformerStarImpedance starImpedance ) { this.starImpedance = starImpedance; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StarImpedance\"")
        private TransformerStarImpedance starImpedance ;
         
        /**
         * Terminal of the power transformer to which this transformer end belongs.
         */
        public Terminal getTerminal () { return terminal; }
        public void setTerminal ( Terminal terminal ) { this.terminal = terminal; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Terminal\"")
        private Terminal terminal ;
         
    }
    /**
     * Transformer end data.
     */
    @Entity
    @Table(name="\"TransformerEndInfo\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TransformerEndInfo
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Transformer mesh impedance (Delta-model) between transformer ends.
     * The typical case is that this class describes the impedance between two
     * transformer ends pair-wise, i.e. the cardinalities at both transformer
     * end associations are 1. However, in cases where two or more transformer
     * ends are modelled the cardinalities are larger than 1.
     */
    @Entity
    @Table(name="\"TransformerMeshImpedance\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TransformerMeshImpedance
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Resistance between the 'from' and the 'to' end, seen from the 'from' end.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero-sequence resistance between the 'from' and the 'to' end, seen from
         * the 'from' end.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Reactance between the 'from' and the 'to' end, seen from the 'from' end.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero-sequence reactance between the 'from' and the 'to' end, seen from
         * the 'from' end.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * From end this mesh impedance is connected to. It determines the voltage
         * reference.
         */
        public TransformerEnd getFromTransformerEnd () { return fromTransformerEnd; }
        public void setFromTransformerEnd ( TransformerEnd fromTransformerEnd ) { this.fromTransformerEnd = fromTransformerEnd; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"FromTransformerEnd\"")
        private TransformerEnd fromTransformerEnd ;
         
        /**
         * 'from' transformer end datasheet this mesh impedance is calculated from.
         * It determines the voltage reference.
         */
        public TransformerEndInfo getFromTransformerEndInfo () { return fromTransformerEndInfo; }
        public void setFromTransformerEndInfo ( TransformerEndInfo fromTransformerEndInfo ) { this.fromTransformerEndInfo = fromTransformerEndInfo; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"FromTransformerEndInfo\"")
        private TransformerEndInfo fromTransformerEndInfo ;
         
    }
    /**
     * Transformer star impedance (Pi-model) that accurately reflects impedance
     * for transformers with 2 or 3 windings. For transformers with 4 or more
     * windings, TransformerMeshImpedance class shall be used.
     * For transmission networks use PowerTransformerEnd impedances (r, r0, x,
     * x0, b, b0, g and g0).
     */
    @Entity
    @Table(name="\"TransformerStarImpedance\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TransformerStarImpedance
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Transformer star impedance (Pi-model) that accurately reflects impedance
     * for transformers with 2 or 3 windings. For transformers with 4 or more
     * windings, TransformerMeshImpedance class shall be used.
     * For transmission networks use PowerTransformerEnd impedances (r, r0, x,
     * x0, b, b0, g and g0).
     */
    @Entity
    @Table(name="\"TransformerStarImpedance1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TransformerStarImpedance1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Resistance of the transformer end.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence series resistance of the transformer end.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Positive sequence series reactance of the transformer end.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero sequence series reactance of the transformer end.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * Transformer end datasheet used to calculate this transformer star impedance.
         */
        public TransformerEndInfo getTransformerEndInfo () { return transformerEndInfo; }
        public void setTransformerEndInfo ( TransformerEndInfo transformerEndInfo ) { this.transformerEndInfo = transformerEndInfo; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TransformerEndInfo\"")
        private TransformerEndInfo transformerEndInfo ;
         
    }
    /**
     * An assembly of two or more coupled windings that transform electrical power
     * between voltage levels. These windings are bound on a common core and placed
     * in the same tank. Transformer tank can be used to model both single-phase
     * and 3-phase transformers.
     */
    @Entity
    @Table(name="\"TransformerTank\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TransformerTank
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Bank this transformer belongs to.
         */
        public PowerTransformer getPowerTransformer () { return powerTransformer; }
        public void setPowerTransformer ( PowerTransformer powerTransformer ) { this.powerTransformer = powerTransformer; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PowerTransformer\"")
        private PowerTransformer powerTransformer ;
         
    }
    /**
     * Transformer tank end represents an individual winding for unbalanced models
     * or for transformer tanks connected into a bank (and bank is modelled with
     * the PowerTransformer).
     */
    @Entity
    @Table(name="\"TransformerTankEnd\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class TransformerTankEnd extends TransformerEnd
    {
        /**
         * Describes the phases carried by a conducting equipment.
         */
        public String getPhases () { return phases; }
        public void setPhases ( String phases ) { this.phases = phases; }
        @Basic()
        @Column(name="\"phases\"")
        private String phases ;
         
        /**
         * Transformer this winding belongs to.
         */
        public TransformerTank getTransformerTank () { return transformerTank; }
        public void setTransformerTank ( TransformerTank transformerTank ) { this.transformerTank = transformerTank; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TransformerTank\"")
        private TransformerTank transformerTank ;
         
    }
     
    /**
     * The unit multipliers defined for the CIM. When applied to unit symbols,
     * the unit symbol is treated as a derived unit. Regardless of the contents
     * of the unit symbol text, the unit symbol shall be treated as if it were
     * a single-character unit symbol. Unit symbols should not contain multipliers,
     * and it should be left to the multiplier to define the multiple for an entire
     * data type.
     * For example, if a unit symbol is "m2Pers" and the multiplier is "k", then
     * the value is k(m**2/s), and the multiplier applies to the entire final
     * value, not to any individual part of the value. This can be conceptualized
     * by substituting a derived unit symbol for the unit type. If one imagines
     * that the symbol "" represents the derived unit "m2Pers", then applying
     * the multiplier "k" can be conceptualized simply as "k".
     * For example, the SI unit for mass is "kg" and not "g". If the unit symbol
     * is defined as "kg", then the multiplier is applied to "kg" as a whole and
     * does not replace the "k" in front of the "g". In this case, the multiplier
     * of "m" would be used with the unit symbol of "kg" to represent one gram.
     * As a text string, this violates the instructions in IEC 80000-1. However,
     * because the unit symbol in CIM is treated as a derived unit instead of
     * as an SI unit, it makes more sense to conceptualize the "kg" as if it were
     * replaced by one of the proposed replacements for the SI mass symbol. If
     * one imagines that the "kg" were replaced by a symbol "", then it is easier
     * to conceptualize the multiplier "m" as creating the proper unit "m", and
     * not the forbidden unit "mkg".
     */
    @Entity
    @Table(name="\"UnitMultiplier\"")
    public static class UnitMultiplier
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * An area of the power system network which is defined for secondary voltage
     * control purposes. A voltage control zone consists of a collection of substations
     * with a designated bus bar section whose voltage will be controlled.
     */
    @Entity
    @Table(name="\"VoltageControlZone\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class VoltageControlZone
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * An area of the power system network which is defined for secondary voltage
     * control purposes. A voltage control zone consists of a collection of substations
     * with a designated bus bar section whose voltage will be controlled.
     */
    @Entity
    @Table(name="\"VoltageControlZone1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class VoltageControlZone1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A VoltageControlZone is controlled by a designated BusbarSection.
         */
        public BusbarSection getBusbarSection () { return busbarSection; }
        public void setBusbarSection ( BusbarSection busbarSection ) { this.busbarSection = busbarSection; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"BusbarSection\"")
        private BusbarSection busbarSection ;
         
        /**
         * A VoltageControlZone may have a voltage regulation schedule.
         */
        public RegulationSchedule getRegulationSchedule () { return regulationSchedule; }
        public void setRegulationSchedule ( RegulationSchedule regulationSchedule ) { this.regulationSchedule = regulationSchedule; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RegulationSchedule\"")
        private RegulationSchedule regulationSchedule ;
         
    }
    /**
     * Parent class supporting relationships to wind turbines type 3 and type
     * 4 and wind plant including their control models.
     */
    @Entity
    @Table(name="\"WindTurbineType3or4Dynamics\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WindTurbineType3or4Dynamics
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    /**
     * Winding connection type.
     */
    @Entity
    @Table(name="\"WindingConnection\"")
    public static class WindingConnection
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Winding connection type.
     */
    @Entity
    @Table(name="\"WindingConnection1\"")
    public static class WindingConnection1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Describes the construction of a multi-conductor wire.
     */
    @Entity
    @Table(name="\"WireAssemblyInfo\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WireAssemblyInfo
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Wire data that can be specified per line segment phase, or for the line
     * segment as a whole in case its phases all have the same wire characteristics.
     */
    @Entity
    @Table(name="\"WireInfo\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WireInfo
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A two terminal and power conducting device of negligible impedance and
     * length represented as zero impedance device that can be used to connect
     * auxiliary equipment to its terminals.
     */
    @Entity
    @Table(name="\"WireSegment\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class WireSegment extends Conductor
    {
    }
    /**
     * Represents a single wire of an alternating current wire segment.
     */
    @Entity
    @Table(name="\"WireSegmentPhase\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WireSegmentPhase
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The phase connection of the wire at both ends.
         */
        public String getPhase () { return phase; }
        public void setPhase ( String phase ) { this.phase = phase; }
        @Basic()
        @Column(name="\"phase\"")
        private String phase ;
         
        /**
         * Number designation for this wire segment phase. Each wire segment phase
         * within a wire segment should have a unique sequence number.
         */
        public Integer getSequenceNumber () { return sequenceNumber; }
        public void setSequenceNumber ( Integer sequenceNumber ) { this.sequenceNumber = sequenceNumber; }
        @Basic()
        @Column(name="\"sequenceNumber\"")
        private Integer sequenceNumber ;
         
        /**
         * The wire segment to which the phase belongs.
         */
        public WireSegment getWireSegment () { return wireSegment; }
        public void setWireSegment ( WireSegment wireSegment ) { this.wireSegment = wireSegment; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"WireSegment\"")
        private WireSegment wireSegment ;
         
    }
    /**
     * Wire spacing data that associates multiple wire positions with the line
     * segment, and allows to calculate line segment impedances. Number of phases
     * can be derived from the number of associated wire positions whose phase
     * is not neutral.
     */
    @Entity
    @Table(name="\"WireSpacingInfo\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WireSpacingInfo
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    public static final Class[] allClasses = new Class[]
    {
        ACLineSegment.class,
        ACLineSegmentPhase.class,
        AsynchronousMachine.class,
        AsynchronousMachineDynamics.class,
        AsynchronousMachineKind.class,
        AsynchronousMachineKind1.class,
        BaseVoltage.class,
        Breaker.class,
        BusbarSection.class,
        Clamp.class,
        ClampAction.class,
        CompositeSwitch.class,
        Conductor.class,
        Connector.class,
        CoolantType.class,
        Cut.class,
        CutAction.class,
        DisconnectingCircuitBreaker.class,
        DisconnectingCircuitBreaker1.class,
        Disconnector.class,
        Disconnector1.class,
        EarthFaultCompensator.class,
        EnergyConnection.class,
        EnergyConsumer.class,
        EnergyConsumerAction.class,
        EnergyConsumerPhase.class,
        EnergySchedulingType.class,
        EnergySource.class,
        EnergySourceAction.class,
        EnergySourcePhase.class,
        ExternalNetworkInjection.class,
        FrequencyConverter.class,
        Fuse.class,
        GeneratingUnit.class,
        Ground.class,
        GroundAction.class,
        GroundDisconnector.class,
        GroundingImpedance.class,
        HydroPump.class,
        Jumper.class,
        JumperAction.class,
        Junction.class,
        Line.class,
        LinearShuntCompensator.class,
        LinearShuntCompensatorPhase.class,
        LoadBreakSwitch.class,
        LoadDynamics.class,
        LoadResponseCharacteristic.class,
        MutualCoupling.class,
        NonlinearShuntCompensator.class,
        NonlinearShuntCompensatorPhase.class,
        NonlinearShuntCompensatorPhasePoint.class,
        NonlinearShuntCompensatorPoint.class,
        PerLengthImpedance.class,
        PerLengthImpedance1.class,
        PerLengthLineParameter.class,
        PerLengthPhaseImpedance.class,
        PerLengthSequenceImpedance.class,
        PetersenCoil.class,
        PetersenCoilModeKind.class,
        PetersenCoilModeKind1.class,
        PhaseCode.class,
        PhaseImpedanceData.class,
        PhaseShuntConnectionKind.class,
        PhaseShuntConnectionKind1.class,
        PhaseTapChanger.class,
        PhaseTapChangerAsymmetrical.class,
        PhaseTapChangerLinear.class,
        PhaseTapChangerNonLinear.class,
        PhaseTapChangerSymmetrical.class,
        PhaseTapChangerTable.class,
        PhaseTapChangerTablePoint.class,
        PhaseTapChangerTabular.class,
        Plant.class,
        PowerCutZone.class,
        PowerElectronicsConnection.class,
        PowerElectronicsConnectionPhase.class,
        PowerTransformer.class,
        PowerTransformerEnd.class,
        ProtectedSwitch.class,
        RatioTapChanger.class,
        RatioTapChangerTable.class,
        RatioTapChangerTable1.class,
        RatioTapChangerTablePoint.class,
        ReactiveCapabilityCurve.class,
        Recloser.class,
        RegulatingCondEq.class,
        RegulatingControl.class,
        RegulatingControl1.class,
        RegulatingControlModeKind.class,
        RegulatingControlModeKind1.class,
        RegulationSchedule.class,
        RotatingMachine.class,
        SVCControlMode.class,
        Sectionaliser.class,
        SeriesCompensator.class,
        ShortCircuitRotorKind.class,
        ShuntCompensator.class,
        ShuntCompensatorAction.class,
        ShuntCompensatorPhase.class,
        SinglePhaseKind.class,
        SinglePhaseKind1.class,
        StaticVarCompensator.class,
        StaticVarCompensatorDynamics.class,
        SubGeographicalRegion.class,
        SvTapStep.class,
        Switch.class,
        Switch1.class,
        SwitchAction.class,
        SwitchPhase.class,
        SwitchSchedule.class,
        SwitchSchedule1.class,
        SynchronousMachine.class,
        SynchronousMachineDynamics.class,
        SynchronousMachineKind.class,
        SynchronousMachineKind1.class,
        SynchronousMachineOperatingMode.class,
        SynchronousMachineOperatingMode1.class,
        TapChanger.class,
        TapChangerControl.class,
        TapChangerControl1.class,
        TapChangerTablePoint.class,
        TapSchedule.class,
        Terminal.class,
        TransformerControlMode.class,
        TransformerControlMode1.class,
        TransformerCoreAdmittance.class,
        TransformerEnd.class,
        TransformerEnd1.class,
        TransformerEndInfo.class,
        TransformerMeshImpedance.class,
        TransformerStarImpedance.class,
        TransformerStarImpedance1.class,
        TransformerTank.class,
        TransformerTankEnd.class,
        UnitMultiplier.class,
        VoltageControlZone.class,
        VoltageControlZone1.class,
        WindTurbineType3or4Dynamics.class,
        WindingConnection.class,
        WindingConnection1.class,
        WireAssemblyInfo.class,
        WireInfo.class,
        WireSegment.class,
        WireSegmentPhase.class,
        WireSpacingInfo.class
    };
}
