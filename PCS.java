package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for PCS
 * Generated by CIMTool http://cimtool.org
 */
public class PCS
{
    /**
     * Defines a system base voltage which is referenced.
     */
    @Entity
    @Table(name="\"BaseVoltage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class BaseVoltage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * The parts of the AC power system that are designed to carry current or
     * that are conductively connected through terminals.
     */
    @Entity
    @Table(name="\"ConductingEquipment\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ConductingEquipment
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Base voltage of this conducting equipment. Use only when there is no voltage
         * level container used and only one base voltage applies. For example, not
         * used for transformers.
         */
        public BaseVoltage getBaseVoltage () { return baseVoltage; }
        public void setBaseVoltage ( BaseVoltage baseVoltage ) { this.baseVoltage = baseVoltage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"BaseVoltage\"")
        private BaseVoltage baseVoltage ;
         
        /**
         * Action involving grounding operation on this conducting equipment.
         */
        public GroundAction getGroundingAction () { return groundingAction; }
        public void setGroundingAction ( GroundAction groundingAction ) { this.groundingAction = groundingAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GroundingAction\"")
        private GroundAction groundingAction ;
         
        /**
         * Jumper action involving jumping operation on this conducting equipment.
         */
        public JumperAction getJumpingAction () { return jumpingAction; }
        public void setJumpingAction ( JumperAction jumpingAction ) { this.jumpingAction = jumpingAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"JumpingAction\"")
        private JumperAction jumpingAction ;
         
        /**
         * The outage that is isolated by the outage isolation equipment.
         */
        public Outage getOutage () { return outage; }
        public void setOutage ( Outage outage ) { this.outage = outage; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Outage\"")
        private Outage outage ;
         
    }
    /**
     * Generic user of energy - a point of consumption on the power system model.
     * EnergyConsumer.pfixed, .qfixed, .pfixedPct and .qfixedPct have meaning
     * only if there is no LoadResponseCharacteristic associated with EnergyConsumer
     * or if LoadResponseCharacteristic.exponentModel is set to False.
     */
    @Entity
    @Table(name="\"EnergyConsumer\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergyConsumer
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Number of individual customers represented by this demand.
         */
        public Integer getCustomerCount () { return customerCount; }
        public void setCustomerCount ( Integer customerCount ) { this.customerCount = customerCount; }
        @Basic()
        @Column(name="\"customerCount\"")
        private Integer customerCount ;
         
        /**
         * Used for Yn and Zn connections. True if the neutral is solidly grounded.
         */
        public Boolean getGrounded () { return grounded; }
        public void setGrounded ( Boolean grounded ) { this.grounded = grounded; }
        @Basic()
        @Column(name="\"grounded\"")
        private Boolean grounded ;
         
        /**
         * Active power of the load. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * For voltage dependent loads the value is at rated voltage.
         * Starting value for a steady state solution.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Active power of the load that is a fixed quantity and does not vary as
         * load group value varies. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         */
        public Double getPfixed () { return pfixed; }
        public void setPfixed ( Double pfixed ) { this.pfixed = pfixed; }
        @Basic()
        @Column(name="\"pfixed\"")
        private Double pfixed ;
         
        /**
         * Fixed active power as a percentage of load group fixed active power. Used
         * to represent the time-varying components. Load sign convention is used,
         * i.e. positive sign means flow out from a node.
         */
        public Double getPfixedPct () { return pfixedPct; }
        public void setPfixedPct ( Double pfixedPct ) { this.pfixedPct = pfixedPct; }
        @Basic()
        @Column(name="\"pfixedPct\"")
        private Double pfixedPct ;
         
        /**
         * The type of phase connection, such as wye or delta.
         */
        public String getPhaseConnection () { return phaseConnection; }
        public void setPhaseConnection ( String phaseConnection ) { this.phaseConnection = phaseConnection; }
        @Basic()
        @Column(name="\"phaseConnection\"")
        private String phaseConnection ;
         
        /**
         * Reactive power of the load. Load sign convention is used, i.e. positive
         * sign means flow out from a node.
         * For voltage dependent loads the value is at rated voltage.
         * Starting value for a steady state solution.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Reactive power of the load that is a fixed quantity and does not vary as
         * load group value varies. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         */
        public Double getQfixed () { return qfixed; }
        public void setQfixed ( Double qfixed ) { this.qfixed = qfixed; }
        @Basic()
        @Column(name="\"qfixed\"")
        private Double qfixed ;
         
        /**
         * Fixed reactive power as a percentage of load group fixed reactive power.
         * Used to represent the time-varying components. Load sign convention is
         * used, i.e. positive sign means flow out from a node.
         */
        public Double getQfixedPct () { return qfixedPct; }
        public void setQfixedPct ( Double qfixedPct ) { this.qfixedPct = qfixedPct; }
        @Basic()
        @Column(name="\"qfixedPct\"")
        private Double qfixedPct ;
         
        /**
         * The energy consumer action that is performed on the energy consumer
         */
        public EnergyConsumerAction getEnergyConsumerAction () { return energyConsumerAction; }
        public void setEnergyConsumerAction ( EnergyConsumerAction energyConsumerAction ) { this.energyConsumerAction = energyConsumerAction; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"EnergyConsumerAction\"")
        private EnergyConsumerAction energyConsumerAction ;
         
        /**
         * Load dynamics model used to describe dynamic behaviour of this energy consumer.
         */
        public LoadDynamics getLoadDynamics () { return loadDynamics; }
        public void setLoadDynamics ( LoadDynamics loadDynamics ) { this.loadDynamics = loadDynamics; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"LoadDynamics\"")
        private LoadDynamics loadDynamics ;
         
        /**
         * The load response characteristic of this load. If missing, this load is
         * assumed to be constant power.
         */
        public LoadResponseCharacteristic getLoadResponse () { return loadResponse; }
        public void setLoadResponse ( LoadResponseCharacteristic loadResponse ) { this.loadResponse = loadResponse; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"LoadResponse\"")
        private LoadResponseCharacteristic loadResponse ;
         
        /**
         * The energy consumer is assigned to this power cut zone.
         */
        public PowerCutZone getPowerCutZone () { return powerCutZone; }
        public void setPowerCutZone ( PowerCutZone powerCutZone ) { this.powerCutZone = powerCutZone; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PowerCutZone\"")
        private PowerCutZone powerCutZone ;
         
    }
    /**
     * Action to connect or disconnect the Energy Consumer from its Terminal
     */
    @Entity
    @Table(name="\"EnergyConsumerAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EnergyConsumerAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A single or set of synchronous machines for converting mechanical power
     * into alternating-current power. For example, individual machines within
     * a set may be defined for scheduling purposes while a single control signal
     * is derived for the set. In this case there would be a GeneratingUnit for
     * each member of the set and an additional GeneratingUnit corresponding to
     * the set.
     */
    @Entity
    @Table(name="\"GeneratingUnit\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GeneratingUnit
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Action on ground as a switching step.
     */
    @Entity
    @Table(name="\"GroundAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GroundAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A synchronous motor-driven pump, typically associated with a pumped storage
     * plant.
     */
    @Entity
    @Table(name="\"HydroPump\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroPump
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Action on jumper as a switching step.
     */
    @Entity
    @Table(name="\"JumperAction\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class JumperAction
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Load whose behaviour is described by reference to a standard model <font
     * color="#0f0f0f">or by definition of a user-defined model.</font>
     * A standard feature of dynamic load behaviour modelling is the ability to
     * associate the same behaviour to multiple energy consumers by means of a
     * single load definition. The load model is always applied to individual
     * bus loads (energy consumers).
     */
    @Entity
    @Table(name="\"LoadDynamics\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class LoadDynamics
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Models the characteristic response of the load demand due to changes in
     * system conditions such as voltage and frequency. It is not related to demand
     * response.
     * If LoadResponseCharacteristic.exponentModel is True, the exponential voltage
     * or frequency dependent models are specified and used as to calculate active
     * and reactive power components of the load model.
     * The equations to calculate active and reactive power components of the
     * load model are internal to the power flow calculation, hence they use different
     * quantities depending on the use case of the data exchange.
     * The equations for exponential voltage dependent load model injected power
     * are:
     * pInjection= Pnominal* (Voltage/cim:BaseVoltage.nominalVoltage) ** cim:LoadResponseCharacteristic.pVoltageExponent
     * qInjection= Qnominal* (Voltage/cim:BaseVoltage.nominalVoltage) ** cim:LoadResponseCharacteristic.qVoltageExponent
     * Where:
     * 1) * means "multiply" and ** is "raised to power of";
     * 2) Pnominal and Qnominal represent the active power and reactive power
     * at nominal voltage as any load described by the voltage exponential model
     * shall be given at nominal voltage. This means that EnergyConsumer.p and
     * EnergyConsumer.q are at nominal voltage.
     * 3) After power flow is solved:
     * -pInjection and qInjection correspond to SvPowerflow.p and SvPowerflow.q
     * respectively.
     * - Voltage corresponds to SvVoltage.v at the TopologicalNode where the load
     * is connected.
     */
    @Entity
    @Table(name="\"LoadResponseCharacteristic\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class LoadResponseCharacteristic
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Document describing details of an active or planned outage in a part of
     * the electrical network.
     * A non-planned outage may be created upon:
     * - a breaker trip,
     * - a fault indicator status change,
     * - a meter event indicating customer outage,
     * - a reception of one or more customer trouble calls, or
     * - an operator command, reflecting information obtained from the field crew.
     * Outage restoration may be performed using a switching plan which complements
     * the outage information with detailed switching activities, including the
     * relationship to the crew and work.
     * A planned outage may be created upon:
     * - a request for service, maintenance or construction work in the field,
     * or
     * - an operator-defined outage for what-if/contingency network analysis.
     */
    @Entity
    @Table(name="\"Outage\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Outage
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    /**
     * An unordered enumeration of phase identifiers. Allows designation of phases
     * for both transmission and distribution equipment, circuits and loads. The
     * enumeration, by itself, does not describe how the phases are connected
     * together or connected to ground. Ground is not explicitly denoted as a
     * phase.
     * Residential and small commercial loads are often served from single-phase,
     * or split-phase, secondary circuits. For the example of s12N, phases 1 and
     * 2 refer to hot wires that are 180 degrees out of phase, while N refers
     * to the neutral wire. Through single-phase transformer connections, these
     * secondary circuits may be served from one or two of the primary phases
     * A, B, and C. For three-phase loads, use the A, B, C phase codes instead
     * of s12N.
     * The integer values are from IEC 61968-9 to support revenue metering applications.
     */
    @Entity
    @Table(name="\"PhaseCode\"")
    public static class PhaseCode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The configuration of phase connections for a single terminal device such
     * as a load or capacitor.
     */
    @Entity
    @Table(name="\"PhaseShuntConnectionKind\"")
    public static class PhaseShuntConnectionKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * An area or zone of the power system which is used for load shedding purposes.
     */
    @Entity
    @Table(name="\"PowerCutZone\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerCutZone
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A connection to the AC network for energy production or consumption that
     * uses power electronics rather than rotating machines.
     */
    @Entity
    @Table(name="\"PowerElectronicsConnection\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerElectronicsConnection
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Maximum fault current this device will contribute, in per-unit of rated
         * current, before the converter protection will trip or bypass.
         */
        public Double getMaxIFault () { return maxIFault; }
        public void setMaxIFault ( Double maxIFault ) { this.maxIFault = maxIFault; }
        @Basic()
        @Column(name="\"maxIFault\"")
        private Double maxIFault ;
         
        /**
         * Maximum reactive power limit. This is the maximum (nameplate) limit for
         * the unit.
         */
        public Double getMaxQ () { return maxQ; }
        public void setMaxQ ( Double maxQ ) { this.maxQ = maxQ; }
        @Basic()
        @Column(name="\"maxQ\"")
        private Double maxQ ;
         
        /**
         * Minimum reactive power limit for the unit. This is the minimum (nameplate)
         * limit for the unit.
         */
        public Double getMinQ () { return minQ; }
        public void setMinQ ( Double minQ ) { this.minQ = minQ; }
        @Basic()
        @Column(name="\"minQ\"")
        private Double minQ ;
         
        /**
         * Active power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Reactive power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Equivalent resistance (RG) of generator. RG is considered for the calculation
         * of all currents, except for the calculation of the peak current ip. Used
         * for short circuit data exchange according to IEC 60909.
         */
        public Double getR () { return r; }
        public void setR ( Double r ) { this.r = r; }
        @Basic()
        @Column(name="\"r\"")
        private Double r ;
         
        /**
         * Zero sequence resistance of the synchronous machine.
         */
        public Double getR0 () { return r0; }
        public void setR0 ( Double r0 ) { this.r0 = r0; }
        @Basic()
        @Column(name="\"r0\"")
        private Double r0 ;
         
        /**
         * Nameplate apparent power rating for the unit.
         * The attribute shall have a positive value.
         */
        public Double getRatedS () { return ratedS; }
        public void setRatedS ( Double ratedS ) { this.ratedS = ratedS; }
        @Basic()
        @Column(name="\"ratedS\"")
        private Double ratedS ;
         
        /**
         * Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
         * for short circuit data exchange according to IEC 60909.
         * The attribute shall be a positive value.
         */
        public Double getRatedU () { return ratedU; }
        public void setRatedU ( Double ratedU ) { this.ratedU = ratedU; }
        @Basic()
        @Column(name="\"ratedU\"")
        private Double ratedU ;
         
        /**
         * Negative sequence Thevenin resistance.
         */
        public Double getRn () { return rn; }
        public void setRn ( Double rn ) { this.rn = rn; }
        @Basic()
        @Column(name="\"rn\"")
        private Double rn ;
         
        /**
         * Positive sequence Thevenin reactance.
         */
        public Double getX () { return x; }
        public void setX ( Double x ) { this.x = x; }
        @Basic()
        @Column(name="\"x\"")
        private Double x ;
         
        /**
         * Zero sequence Thevenin reactance.
         */
        public Double getX0 () { return x0; }
        public void setX0 ( Double x0 ) { this.x0 = x0; }
        @Basic()
        @Column(name="\"x0\"")
        private Double x0 ;
         
        /**
         * Negative sequence Thevenin reactance.
         */
        public Double getXn () { return xn; }
        public void setXn ( Double xn ) { this.xn = xn; }
        @Basic()
        @Column(name="\"xn\"")
        private Double xn ;
         
        /**
         * The wind turbine type 3 or type 4 dynamics model associated with this power
         * electronics connection.
         */
        public WindTurbineType3or4Dynamics getWindTurbineType3or4Dynamics () { return windTurbineType3or4Dynamics; }
        public void setWindTurbineType3or4Dynamics ( WindTurbineType3or4Dynamics windTurbineType3or4Dynamics ) { this.windTurbineType3or4Dynamics = windTurbineType3or4Dynamics; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"WindTurbineType3or4Dynamics\"")
        private WindTurbineType3or4Dynamics windTurbineType3or4Dynamics ;
         
    }
    /**
     * Specifies a set of equipment that works together to control a power system
     * quantity such as voltage or flow.
     * Remote bus voltage control is possible by specifying the controlled terminal
     * located at some place remote from the controlling equipment.
     * The specified terminal shall be associated with the connectivity node of
     * the controlled point. The most specific subtype of RegulatingControl shall
     * be used in case such equipment participate in the control, e.g. TapChangerControl
     * for tap changers.
     * For flow control, load sign convention is used, i.e. positive sign means
     * flow out from a TopologicalNode (bus) into the conducting equipment.
     * The attribute minAllowedTargetValue and maxAllowedTargetValue are required
     * in the following cases:
     * - For a power generating module operated in power factor control mode to
     * specify maximum and minimum power factor values;
     * - Whenever it is necessary to have an off center target voltage for the
     * tap changer regulator. For instance, due to long cables to off shore wind
     * farms and the need to have a simpler setup at the off shore transformer
     * platform, the voltage is controlled from the land at the connection point
     * for the off shore wind farm. Since there usually is a voltage rise along
     * the cable, there is typical and overvoltage of up 3-4 kV compared to the
     * on shore station. Thus in normal operation the tap changer on the on shore
     * station is operated with a target set point, which is in the lower parts
     * of the dead band.
     * The attributes minAllowedTargetValue and maxAllowedTargetValue are not
     * related to the attribute targetDeadband and thus they are not treated as
     * an alternative of the targetDeadband. They are needed due to limitations
     * in the local substation controller. The attribute targetDeadband is used
     * to prevent the power flow from move the tap position in circles (hunting)
     * that is to be used regardless of the attributes minAllowedTargetValue and
     * maxAllowedTargetValue.
     */
    @Entity
    @Table(name="\"RegulatingControl\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RegulatingControl
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The regulation is performed in a discrete mode. This applies to equipment
         * with discrete controls, e.g. tap changers and shunt compensators.
         */
        public Boolean getDiscrete () { return discrete; }
        public void setDiscrete ( Boolean discrete ) { this.discrete = discrete; }
        @Basic()
        @Column(name="\"discrete\"")
        private Boolean discrete ;
         
        /**
         * The flag tells if regulation is enabled.
         */
        public Boolean getEnabled () { return enabled; }
        public void setEnabled ( Boolean enabled ) { this.enabled = enabled; }
        @Basic()
        @Column(name="\"enabled\"")
        private Boolean enabled ;
         
        /**
         * Maximum allowed target value (RegulatingControl.targetValue).
         */
        public Double getMaxAllowedTargetValue () { return maxAllowedTargetValue; }
        public void setMaxAllowedTargetValue ( Double maxAllowedTargetValue ) { this.maxAllowedTargetValue = maxAllowedTargetValue; }
        @Basic()
        @Column(name="\"maxAllowedTargetValue\"")
        private Double maxAllowedTargetValue ;
         
        /**
         * Minimum allowed target value (RegulatingControl.targetValue).
         */
        public Double getMinAllowedTargetValue () { return minAllowedTargetValue; }
        public void setMinAllowedTargetValue ( Double minAllowedTargetValue ) { this.minAllowedTargetValue = minAllowedTargetValue; }
        @Basic()
        @Column(name="\"minAllowedTargetValue\"")
        private Double minAllowedTargetValue ;
         
        /**
         * The regulating control mode presently available. This specification allows
         * for determining the kind of regulation without need for obtaining the units
         * from a schedule.
         */
        public String getMode () { return mode; }
        public void setMode ( String mode ) { this.mode = mode; }
        @Basic()
        @Column(name="\"mode\"")
        private String mode ;
         
        /**
         * Phase voltage controlling this regulator, measured at regulator location.
         */
        public String getMonitoredPhase () { return monitoredPhase; }
        public void setMonitoredPhase ( String monitoredPhase ) { this.monitoredPhase = monitoredPhase; }
        @Basic()
        @Column(name="\"monitoredPhase\"")
        private String monitoredPhase ;
         
        /**
         * This is a deadband used with discrete control to avoid excessive update
         * of controls like tap changers and shunt compensator banks while regulating.
         * The units of those appropriate for the mode. The attribute shall be a positive
         * value or zero. If RegulatingControl.discrete is set to "false", the RegulatingControl.targetDeadband
         * is to be ignored.
         * Note that for instance, if the targetValue is 100 kV and the targetDeadband
         * is 2 kV the range is from 99 to 101 kV.
         */
        public Double getTargetDeadband () { return targetDeadband; }
        public void setTargetDeadband ( Double targetDeadband ) { this.targetDeadband = targetDeadband; }
        @Basic()
        @Column(name="\"targetDeadband\"")
        private Double targetDeadband ;
         
        /**
         * The target value specified for case input. This value can be used for the
         * target value without the use of schedules. The value has the units appropriate
         * to the mode attribute.
         */
        public Double getTargetValue () { return targetValue; }
        public void setTargetValue ( Double targetValue ) { this.targetValue = targetValue; }
        @Basic()
        @Column(name="\"targetValue\"")
        private Double targetValue ;
         
        /**
         * Specify the multiplier for used for the targetValue.
         */
        public String getTargetValueUnitMultiplier () { return targetValueUnitMultiplier; }
        public void setTargetValueUnitMultiplier ( String targetValueUnitMultiplier ) { this.targetValueUnitMultiplier = targetValueUnitMultiplier; }
        @Basic()
        @Column(name="\"targetValueUnitMultiplier\"")
        private String targetValueUnitMultiplier ;
         
        /**
         * The terminal associated with this regulating control. The terminal is associated
         * instead of a node, since the terminal could connect into either a topological
         * node or a connectivity node. Sometimes it is useful to model regulation
         * at a terminal of a bus bar object.
         */
        public Terminal getTerminal () { return terminal; }
        public void setTerminal ( Terminal terminal ) { this.terminal = terminal; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Terminal\"")
        private Terminal terminal ;
         
    }
     
    /**
     * The kind of regulation model. For example regulating voltage, reactive
     * power, active power, etc.
     */
    @Entity
    @Table(name="\"RegulatingControlModeKind\"")
    public static class RegulatingControlModeKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A rotating machine which may be used as a generator or motor.
     */
    @Entity
    @Table(name="\"RotatingMachine\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RotatingMachine
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Active power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getP () { return p; }
        public void setP ( Double p ) { this.p = p; }
        @Basic()
        @Column(name="\"p\"")
        private Double p ;
         
        /**
         * Reactive power injection. Load sign convention is used, i.e. positive sign
         * means flow out from a node.
         * Starting value for a steady state solution.
         */
        public Double getQ () { return q; }
        public void setQ ( Double q ) { this.q = q; }
        @Basic()
        @Column(name="\"q\"")
        private Double q ;
         
        /**
         * Power factor (nameplate data). It is primarily used for short circuit data
         * exchange according to IEC 60909. The attribute cannot be a negative value.
         */
        public Double getRatedPowerFactor () { return ratedPowerFactor; }
        public void setRatedPowerFactor ( Double ratedPowerFactor ) { this.ratedPowerFactor = ratedPowerFactor; }
        @Basic()
        @Column(name="\"ratedPowerFactor\"")
        private Double ratedPowerFactor ;
         
        /**
         * Nameplate apparent power rating for the unit.
         * The attribute shall have a positive value.
         */
        public Double getRatedS () { return ratedS; }
        public void setRatedS ( Double ratedS ) { this.ratedS = ratedS; }
        @Basic()
        @Column(name="\"ratedS\"")
        private Double ratedS ;
         
        /**
         * Rated voltage (nameplate data, Ur in IEC 60909-0). It is primarily used
         * for short circuit data exchange according to IEC 60909.
         * The attribute shall be a positive value.
         */
        public Double getRatedU () { return ratedU; }
        public void setRatedU ( Double ratedU ) { this.ratedU = ratedU; }
        @Basic()
        @Column(name="\"ratedU\"")
        private Double ratedU ;
         
        /**
         * A synchronous machine may operate as a generator and as such becomes a
         * member of a generating unit.
         */
        public GeneratingUnit getGeneratingUnit () { return generatingUnit; }
        public void setGeneratingUnit ( GeneratingUnit generatingUnit ) { this.generatingUnit = generatingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GeneratingUnit\"")
        private GeneratingUnit generatingUnit ;
         
        /**
         * The synchronous machine drives the turbine which moves the water from a
         * low elevation to a higher elevation. The direction of machine rotation
         * for pumping may or may not be the same as for generating.
         */
        public HydroPump getHydroPump () { return hydroPump; }
        public void setHydroPump ( HydroPump hydroPump ) { this.hydroPump = hydroPump; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroPump\"")
        private HydroPump hydroPump ;
         
    }
    /**
     * An AC electrical connection point to a piece of conducting equipment. Terminals
     * are connected at physical connection points called connectivity nodes.
     */
    @Entity
    @Table(name="\"Terminal\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Terminal
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    /**
     * The unit multipliers defined for the CIM. When applied to unit symbols,
     * the unit symbol is treated as a derived unit. Regardless of the contents
     * of the unit symbol text, the unit symbol shall be treated as if it were
     * a single-character unit symbol. Unit symbols should not contain multipliers,
     * and it should be left to the multiplier to define the multiple for an entire
     * data type.
     * For example, if a unit symbol is "m2Pers" and the multiplier is "k", then
     * the value is k(m**2/s), and the multiplier applies to the entire final
     * value, not to any individual part of the value. This can be conceptualized
     * by substituting a derived unit symbol for the unit type. If one imagines
     * that the symbol "�" represents the derived unit "m2Pers", then applying
     * the multiplier "k" can be conceptualized simply as "k�".
     * For example, the SI unit for mass is "kg" and not "g". If the unit symbol
     * is defined as "kg", then the multiplier is applied to "kg" as a whole and
     * does not replace the "k" in front of the "g". In this case, the multiplier
     * of "m" would be used with the unit symbol of "kg" to represent one gram.
     * As a text string, this violates the instructions in IEC 80000-1. However,
     * because the unit symbol in CIM is treated as a derived unit instead of
     * as an SI unit, it makes more sense to conceptualize the "kg" as if it were
     * replaced by one of the proposed replacements for the SI mass symbol. If
     * one imagines that the "kg" were replaced by a symbol "�", then it is easier
     * to conceptualize the multiplier "m" as creating the proper unit "m�", and
     * not the forbidden unit "mkg".
     */
    @Entity
    @Table(name="\"UnitMultiplier\"")
    public static class UnitMultiplier
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Parent class supporting relationships to wind turbines type 3 and type
     * 4 and wind plant including their control models.
     */
    @Entity
    @Table(name="\"WindTurbineType3or4Dynamics\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class WindTurbineType3or4Dynamics
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
     
    public static final Class[] allClasses = new Class[]
    {
        BaseVoltage.class,
        ConductingEquipment.class,
        EnergyConsumer.class,
        EnergyConsumerAction.class,
        GeneratingUnit.class,
        GroundAction.class,
        HydroPump.class,
        JumperAction.class,
        LoadDynamics.class,
        LoadResponseCharacteristic.class,
        Outage.class,
        PhaseCode.class,
        PhaseShuntConnectionKind.class,
        PowerCutZone.class,
        PowerElectronicsConnection.class,
        RegulatingControl.class,
        RegulatingControlModeKind.class,
        RotatingMachine.class,
        Terminal.class,
        UnitMultiplier.class,
        WindTurbineType3or4Dynamics.class
    };
}
