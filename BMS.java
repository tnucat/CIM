package au.com.langdale.cimtool.generated;
import javax.persistence.*;
/**
 * Annotated java for BMS
 * Generated by CIMTool http://cimtool.org
 */
public class BMS
{
    /**
     * Combustion turbine air compressor which is an integral part of a compressed
     * air energy storage (CAES) plant.
     */
    @Entity
    @Table(name="\"AirCompressor\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class AirCompressor
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Rating of the CAES air compressor.
         */
        public Double getAirCompressorRating () { return airCompressorRating; }
        public void setAirCompressorRating ( Double airCompressorRating ) { this.airCompressorRating = airCompressorRating; }
        @Basic()
        @Column(name="\"airCompressorRating\"")
        private Double airCompressorRating ;
         
        /**
         * An air compressor may be a member of a compressed air energy storage plant.
         */
        public CAESPlant getCAESPlant () { return cAESPlant; }
        public void setCAESPlant ( CAESPlant cAESPlant ) { this.cAESPlant = cAESPlant; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CAESPlant\"")
        private CAESPlant cAESPlant ;
         
        /**
         * A CAES air compressor is driven by combustion turbine.
         */
        public CombustionTurbine getCombustionTurbine () { return combustionTurbine; }
        public void setCombustionTurbine ( CombustionTurbine combustionTurbine ) { this.combustionTurbine = combustionTurbine; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CombustionTurbine\"")
        private CombustionTurbine combustionTurbine ;
         
    }
     
    /**
     * The state of the battery unit.
     */
    @Entity
    @Table(name="\"BatteryStateKind\"")
    public static class BatteryStateKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The state of the battery unit.
     */
    @Entity
    @Table(name="\"BatteryStateKind1\"")
    public static class BatteryStateKind1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * An electrochemical energy storage device.
     */
    @Entity
    @Table(name="\"BatteryUnit\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class BatteryUnit extends PowerElectronicsUnit
    {
    }
    /**
     * An electrochemical energy storage device.
     */
    @Entity
    @Table(name="\"BatteryUnit1\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class BatteryUnit1 extends PowerElectronicsUnit
    {
        /**
         * The current state of the battery (charging, full, etc.).
         */
        public String getBatteryState () { return batteryState; }
        public void setBatteryState ( String batteryState ) { this.batteryState = batteryState; }
        @Basic()
        @Column(name="\"batteryState\"")
        private String batteryState ;
         
        /**
         * Full energy storage capacity of the battery. The attribute shall be a positive
         * value.
         */
        public Double getRatedE () { return ratedE; }
        public void setRatedE ( Double ratedE ) { this.ratedE = ratedE; }
        @Basic()
        @Column(name="\"ratedE\"")
        private Double ratedE ;
         
        /**
         * Amount of energy currently stored. The attribute shall be a positive value
         * or zero and lower than BatteryUnit.ratedE.
         */
        public Double getStoredE () { return storedE; }
        public void setStoredE ( Double storedE ) { this.storedE = storedE; }
        @Basic()
        @Column(name="\"storedE\"")
        private Double storedE ;
         
    }
    /**
     * Compressed air energy storage plant.
     */
    @Entity
    @Table(name="\"CAESPlant\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CAESPlant
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Compressed air energy storage plant.
     */
    @Entity
    @Table(name="\"CAESPlant1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CAESPlant1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The rated energy storage capacity. The attribute shall be a positive value.
         */
        public Double getEnergyStorageCapacity () { return energyStorageCapacity; }
        public void setEnergyStorageCapacity ( Double energyStorageCapacity ) { this.energyStorageCapacity = energyStorageCapacity; }
        @Basic()
        @Column(name="\"energyStorageCapacity\"")
        private Double energyStorageCapacity ;
         
        /**
         * The CAES plant's gross rated generating capacity. The attribute shall be
         * a positive value.
         */
        public Double getRatedCapacityP () { return ratedCapacityP; }
        public void setRatedCapacityP ( Double ratedCapacityP ) { this.ratedCapacityP = ratedCapacityP; }
        @Basic()
        @Column(name="\"ratedCapacityP\"")
        private Double ratedCapacityP ;
         
        /**
         * An air compressor may be a member of a compressed air energy storage plant.
         */
        public AirCompressor getAirCompressor () { return airCompressor; }
        public void setAirCompressor ( AirCompressor airCompressor ) { this.airCompressor = airCompressor; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"AirCompressor\"")
        private AirCompressor airCompressor ;
         
        /**
         * A thermal generating unit may be a member of a compressed air energy storage
         * plant.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
    /**
     * A set of thermal generating units for the production of electrical energy
     * and process steam (usually from the output of the steam turbines). The
     * steam sendout is typically used for industrial purposes or for municipal
     * heating and cooling.
     */
    @Entity
    @Table(name="\"CogenerationPlant\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CogenerationPlant
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The high pressure steam sendout.
         */
        public Double getCogenHPSendoutRating () { return cogenHPSendoutRating; }
        public void setCogenHPSendoutRating ( Double cogenHPSendoutRating ) { this.cogenHPSendoutRating = cogenHPSendoutRating; }
        @Basic()
        @Column(name="\"cogenHPSendoutRating\"")
        private Double cogenHPSendoutRating ;
         
        /**
         * The high pressure steam rating.
         */
        public Double getCogenHPSteamRating () { return cogenHPSteamRating; }
        public void setCogenHPSteamRating ( Double cogenHPSteamRating ) { this.cogenHPSteamRating = cogenHPSteamRating; }
        @Basic()
        @Column(name="\"cogenHPSteamRating\"")
        private Double cogenHPSteamRating ;
         
        /**
         * The low pressure steam sendout.
         */
        public Double getCogenLPSendoutRating () { return cogenLPSendoutRating; }
        public void setCogenLPSendoutRating ( Double cogenLPSendoutRating ) { this.cogenLPSendoutRating = cogenLPSendoutRating; }
        @Basic()
        @Column(name="\"cogenLPSendoutRating\"")
        private Double cogenLPSendoutRating ;
         
        /**
         * The low pressure steam rating.
         */
        public Double getCogenLPSteamRating () { return cogenLPSteamRating; }
        public void setCogenLPSteamRating ( Double cogenLPSteamRating ) { this.cogenLPSteamRating = cogenLPSteamRating; }
        @Basic()
        @Column(name="\"cogenLPSteamRating\"")
        private Double cogenLPSteamRating ;
         
        /**
         * The rated output active power of the cogeneration plant.
         * The attribute shall be a positive value.
         */
        public Double getRatedP () { return ratedP; }
        public void setRatedP ( Double ratedP ) { this.ratedP = ratedP; }
        @Basic()
        @Column(name="\"ratedP\"")
        private Double ratedP ;
         
        /**
         * A cogeneration plant has a steam sendout schedule.
         */
        public SteamSendoutSchedule getSteamSendoutSchedule () { return steamSendoutSchedule; }
        public void setSteamSendoutSchedule ( SteamSendoutSchedule steamSendoutSchedule ) { this.steamSendoutSchedule = steamSendoutSchedule; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SteamSendoutSchedule\"")
        private SteamSendoutSchedule steamSendoutSchedule ;
         
    }
    /**
     * A set of combustion turbines and steam turbines where the exhaust heat
     * from the combustion turbines is recovered to make steam for the steam turbines,
     * resulting in greater overall plant efficiency.
     */
    @Entity
    @Table(name="\"CombinedCyclePlant\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CombinedCyclePlant
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The combined cycle plant's active power output rating.
         */
        public Double getCombCyclePlantRating () { return combCyclePlantRating; }
        public void setCombCyclePlantRating ( Double combCyclePlantRating ) { this.combCyclePlantRating = combCyclePlantRating; }
        @Basic()
        @Column(name="\"combCyclePlantRating\"")
        private Double combCyclePlantRating ;
         
    }
    /**
     * A prime mover that is typically fuelled by gas or light oil.
     */
    @Entity
    @Table(name="\"CombustionTurbine\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class CombustionTurbine
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Accounts for tracking emissions usage and credits for thermal generating
     * units. A unit may have zero or more emission accounts, and will typically
     * have one for tracking usage and one for tracking credits.
     */
    @Entity
    @Table(name="\"EmissionAccount\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EmissionAccount
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The type of emission, for example sulfur dioxide (SO2). The y1AxisUnits
         * of the curve contains the unit of measure (e.g. kg) and the emissionType
         * is the type of emission (e.g. sulfur dioxide).
         */
        public String getEmissionType () { return emissionType; }
        public void setEmissionType ( String emissionType ) { this.emissionType = emissionType; }
        @Basic()
        @Column(name="\"emissionType\"")
        private String emissionType ;
         
        /**
         * The source of the emission value.
         */
        public String getEmissionValueSource () { return emissionValueSource; }
        public void setEmissionValueSource ( String emissionValueSource ) { this.emissionValueSource = emissionValueSource; }
        @Basic()
        @Column(name="\"emissionValueSource\"")
        private String emissionValueSource ;
         
        /**
         * A thermal generating unit may have one or more emission allowance accounts.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
    /**
     * Relationship between the unit's emission rate in units of mass per hour
     * (Y-axis) and output active power (X-axis) for a given type of emission.
     * This curve applies when only one type of fuel is being burned.
     */
    @Entity
    @Table(name="\"EmissionCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class EmissionCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The emission content per quantity of fuel burned.
         */
        public Double getEmissionContent () { return emissionContent; }
        public void setEmissionContent ( Double emissionContent ) { this.emissionContent = emissionContent; }
        @Basic()
        @Column(name="\"emissionContent\"")
        private Double emissionContent ;
         
        /**
         * The type of emission, which also gives the production rate measurement
         * unit. The y1AxisUnits of the curve contains the unit of measure (e.g. kg)
         * and the emissionType is the type of emission (e.g. sulfur dioxide).
         */
        public String getEmissionType () { return emissionType; }
        public void setEmissionType ( String emissionType ) { this.emissionType = emissionType; }
        @Basic()
        @Column(name="\"emissionType\"")
        private String emissionType ;
         
        /**
         * Flag is set to true when output is expressed in net active power.
         */
        public Boolean getIsNetGrossP () { return isNetGrossP; }
        public void setIsNetGrossP ( Boolean isNetGrossP ) { this.isNetGrossP = isNetGrossP; }
        @Basic()
        @Column(name="\"isNetGrossP\"")
        private Boolean isNetGrossP ;
         
        /**
         * A thermal generating unit may have one or more emission curves.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
     
    /**
     * The type of emission.
     */
    @Entity
    @Table(name="\"EmissionType\"")
    public static class EmissionType
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The type of emission.
     */
    @Entity
    @Table(name="\"EmissionType1\"")
    public static class EmissionType1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The source of the emission value.
     */
    @Entity
    @Table(name="\"EmissionValueSource\"")
    public static class EmissionValueSource
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The source of the emission value.
     */
    @Entity
    @Table(name="\"EmissionValueSource1\"")
    public static class EmissionValueSource1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * The fossil fuel consumed by the non-nuclear thermal generating unit. For
     * example, coal, oil, gas, etc. These are the specific fuels that the generating
     * unit can consume.
     */
    @Entity
    @Table(name="\"FossilFuel\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class FossilFuel
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The type of fossil fuel, such as coal, oil, or gas.
         */
        public String getFossilFuelType () { return fossilFuelType; }
        public void setFossilFuelType ( String fossilFuelType ) { this.fossilFuelType = fossilFuelType; }
        @Basic()
        @Column(name="\"fossilFuelType\"")
        private String fossilFuelType ;
         
        /**
         * The cost in terms of heat value for the given type of fuel.
         */
        public Double getFuelCost () { return fuelCost; }
        public void setFuelCost ( Double fuelCost ) { this.fuelCost = fuelCost; }
        @Basic()
        @Column(name="\"fuelCost\"")
        private Double fuelCost ;
         
        /**
         * The cost of fuel used for economic dispatching which includes: fuel cost,
         * transportation cost, and incremental maintenance cost.
         */
        public Double getFuelDispatchCost () { return fuelDispatchCost; }
        public void setFuelDispatchCost ( Double fuelDispatchCost ) { this.fuelDispatchCost = fuelDispatchCost; }
        @Basic()
        @Column(name="\"fuelDispatchCost\"")
        private Double fuelDispatchCost ;
         
        /**
         * The efficiency factor for the fuel (per unit) in terms of the effective
         * energy absorbed.
         */
        public Double getFuelEffFactor () { return fuelEffFactor; }
        public void setFuelEffFactor ( Double fuelEffFactor ) { this.fuelEffFactor = fuelEffFactor; }
        @Basic()
        @Column(name="\"fuelEffFactor\"")
        private Double fuelEffFactor ;
         
        /**
         * Handling and processing cost associated with this fuel.
         */
        public Double getFuelHandlingCost () { return fuelHandlingCost; }
        public void setFuelHandlingCost ( Double fuelHandlingCost ) { this.fuelHandlingCost = fuelHandlingCost; }
        @Basic()
        @Column(name="\"fuelHandlingCost\"")
        private Double fuelHandlingCost ;
         
        /**
         * The amount of heat per weight (or volume) of the given type of fuel.
         */
        public Double getFuelHeatContent () { return fuelHeatContent; }
        public void setFuelHeatContent ( Double fuelHeatContent ) { this.fuelHeatContent = fuelHeatContent; }
        @Basic()
        @Column(name="\"fuelHeatContent\"")
        private Double fuelHeatContent ;
         
        /**
         * Relative amount of the given type of fuel, when multiple fuels are being
         * consumed.
         */
        public Double getFuelMixture () { return fuelMixture; }
        public void setFuelMixture ( Double fuelMixture ) { this.fuelMixture = fuelMixture; }
        @Basic()
        @Column(name="\"fuelMixture\"")
        private Double fuelMixture ;
         
        /**
         * The fuel's fraction of pollution credit per unit of heat content.
         */
        public Double getFuelSulfur () { return fuelSulfur; }
        public void setFuelSulfur ( Double fuelSulfur ) { this.fuelSulfur = fuelSulfur; }
        @Basic()
        @Column(name="\"fuelSulfur\"")
        private Double fuelSulfur ;
         
        /**
         * The active power output level of the unit at which the given type of fuel
         * is switched on. This fuel (e.g., oil) is sometimes used to supplement the
         * base fuel (e.g., coal) at high active power output levels.
         */
        public Double getHighBreakpointP () { return highBreakpointP; }
        public void setHighBreakpointP ( Double highBreakpointP ) { this.highBreakpointP = highBreakpointP; }
        @Basic()
        @Column(name="\"highBreakpointP\"")
        private Double highBreakpointP ;
         
        /**
         * The active power output level of the unit at which the given type of fuel
         * is switched off. This fuel (e.g., oil) is sometimes used to stabilize the
         * base fuel (e.g., coal) at low active power output levels.
         */
        public Double getLowBreakpointP () { return lowBreakpointP; }
        public void setLowBreakpointP ( Double lowBreakpointP ) { this.lowBreakpointP = lowBreakpointP; }
        @Basic()
        @Column(name="\"lowBreakpointP\"")
        private Double lowBreakpointP ;
         
        /**
         * A thermal generating unit may have one or more fossil fuels.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
    /**
     * The amount of fuel of a given type which is allocated for consumption over
     * a specified period of time.
     */
    @Entity
    @Table(name="\"FuelAllocationSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class FuelAllocationSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The end time and date of the fuel allocation schedule.
         */
        public String getFuelAllocationEndDate () { return fuelAllocationEndDate; }
        public void setFuelAllocationEndDate ( String fuelAllocationEndDate ) { this.fuelAllocationEndDate = fuelAllocationEndDate; }
        @Basic()
        @Column(name="\"fuelAllocationEndDate\"")
        private String fuelAllocationEndDate ;
         
        /**
         * The start time and date of the fuel allocation schedule.
         */
        public String getFuelAllocationStartDate () { return fuelAllocationStartDate; }
        public void setFuelAllocationStartDate ( String fuelAllocationStartDate ) { this.fuelAllocationStartDate = fuelAllocationStartDate; }
        @Basic()
        @Column(name="\"fuelAllocationStartDate\"")
        private String fuelAllocationStartDate ;
         
        /**
         * The type of fuel, which also indicates the corresponding measurement unit.
         */
        public String getFuelType () { return fuelType; }
        public void setFuelType ( String fuelType ) { this.fuelType = fuelType; }
        @Basic()
        @Column(name="\"fuelType\"")
        private String fuelType ;
         
        /**
         * The maximum amount of fuel that is allocated for consumption for the scheduled
         * time period.
         */
        public Double getMaxFuelAllocation () { return maxFuelAllocation; }
        public void setMaxFuelAllocation ( Double maxFuelAllocation ) { this.maxFuelAllocation = maxFuelAllocation; }
        @Basic()
        @Column(name="\"maxFuelAllocation\"")
        private Double maxFuelAllocation ;
         
        /**
         * The minimum amount of fuel that is allocated for consumption for the scheduled
         * time period, e.g., based on a "take-or-pay" contract.
         */
        public Double getMinFuelAllocation () { return minFuelAllocation; }
        public void setMinFuelAllocation ( Double minFuelAllocation ) { this.minFuelAllocation = minFuelAllocation; }
        @Basic()
        @Column(name="\"minFuelAllocation\"")
        private Double minFuelAllocation ;
         
        /**
         * A fuel allocation schedule shall have a fossil fuel.
         */
        public FossilFuel getFossilFuel () { return fossilFuel; }
        public void setFossilFuel ( FossilFuel fossilFuel ) { this.fossilFuel = fossilFuel; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"FossilFuel\"")
        private FossilFuel fossilFuel ;
         
        /**
         * A thermal generating unit may have one or more fuel allocation schedules.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
     
    /**
     * Type of fuel.
     */
    @Entity
    @Table(name="\"FuelType\"")
    public static class FuelType
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Type of fuel.
     */
    @Entity
    @Table(name="\"FuelType1\"")
    public static class FuelType1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Relationship between unit operating cost (Y-axis) and unit output active
     * power (X-axis). The operating cost curve for thermal units is derived from
     * heat input and fuel costs. The operating cost curve for hydro units is
     * derived from water flow rates and equivalent water costs.
     */
    @Entity
    @Table(name="\"GenUnitOpCostCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GenUnitOpCostCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Flag is set to true when output is expressed in net active power.
         */
        public Boolean getIsNetGrossP () { return isNetGrossP; }
        public void setIsNetGrossP ( Boolean isNetGrossP ) { this.isNetGrossP = isNetGrossP; }
        @Basic()
        @Column(name="\"isNetGrossP\"")
        private Boolean isNetGrossP ;
         
        /**
         * A generating unit may have one or more cost curves, depending upon fuel
         * mixture and fuel cost.
         */
        public GeneratingUnit getGeneratingUnit () { return generatingUnit; }
        public void setGeneratingUnit ( GeneratingUnit generatingUnit ) { this.generatingUnit = generatingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GeneratingUnit\"")
        private GeneratingUnit generatingUnit ;
         
    }
    /**
     * The generating unit's Operator-approved current operating schedule (or
     * plan), typically produced with the aid of unit commitment type analyses.
     * The X-axis represents absolute time. The Y1-axis represents the status
     * (0=off-line and unavailable: 1=available: 2=must run: 3=must run at fixed
     * power value: etc.). The Y2-axis represents the must run fixed power value
     * where required.
     */
    @Entity
    @Table(name="\"GenUnitOpSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GenUnitOpSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A generating unit may have an operating schedule, indicating the planned
         * operation of the unit.
         */
        public GeneratingUnit getGeneratingUnit () { return generatingUnit; }
        public void setGeneratingUnit ( GeneratingUnit generatingUnit ) { this.generatingUnit = generatingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GeneratingUnit\"")
        private GeneratingUnit generatingUnit ;
         
    }
    /**
     * A single or set of synchronous machines for converting mechanical power
     * into alternating-current power. For example, individual machines within
     * a set may be defined for scheduling purposes while a single control signal
     * is derived for the set. In this case there would be a GeneratingUnit for
     * each member of the set and an additional GeneratingUnit corresponding to
     * the set.
     */
    @Entity
    @Table(name="\"GeneratingUnit\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GeneratingUnit
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A single or set of synchronous machines for converting mechanical power
     * into alternating-current power. For example, individual machines within
     * a set may be defined for scheduling purposes while a single control signal
     * is derived for the set. In this case there would be a GeneratingUnit for
     * each member of the set and an additional GeneratingUnit corresponding to
     * the set.
     */
    @Entity
    @Table(name="\"GeneratingUnit1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GeneratingUnit1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The planned unused capacity (spinning reserve) which can be used to support
         * emergency load.
         */
        public Double getAllocSpinResP () { return allocSpinResP; }
        public void setAllocSpinResP ( Double allocSpinResP ) { this.allocSpinResP = allocSpinResP; }
        @Basic()
        @Column(name="\"allocSpinResP\"")
        private Double allocSpinResP ;
         
        /**
         * The planned unused capacity which can be used to support automatic control
         * overruns.
         */
        public Double getAutoCntrlMarginP () { return autoCntrlMarginP; }
        public void setAutoCntrlMarginP ( Double autoCntrlMarginP ) { this.autoCntrlMarginP = autoCntrlMarginP; }
        @Basic()
        @Column(name="\"autoCntrlMarginP\"")
        private Double autoCntrlMarginP ;
         
        /**
         * For dispatchable units, this value represents the economic active power
         * basepoint, for units that are not dispatchable, this value represents the
         * fixed generation value. The value shall be between the operating low and
         * high limits.
         */
        public Double getBaseP () { return baseP; }
        public void setBaseP ( Double baseP ) { this.baseP = baseP; }
        @Basic()
        @Column(name="\"baseP\"")
        private Double baseP ;
         
        /**
         * Unit control error deadband. When a unit's desired active power change
         * is less than this deadband, then no control pulses will be sent to the
         * unit.
         */
        public Double getControlDeadband () { return controlDeadband; }
        public void setControlDeadband ( Double controlDeadband ) { this.controlDeadband = controlDeadband; }
        @Basic()
        @Column(name="\"controlDeadband\"")
        private Double controlDeadband ;
         
        /**
         * Pulse high limit which is the largest control pulse that the unit can respond
         * to.
         */
        public Double getControlPulseHigh () { return controlPulseHigh; }
        public void setControlPulseHigh ( Double controlPulseHigh ) { this.controlPulseHigh = controlPulseHigh; }
        @Basic()
        @Column(name="\"controlPulseHigh\"")
        private Double controlPulseHigh ;
         
        /**
         * Pulse low limit which is the smallest control pulse that the unit can respond
         * to.
         */
        public Double getControlPulseLow () { return controlPulseLow; }
        public void setControlPulseLow ( Double controlPulseLow ) { this.controlPulseLow = controlPulseLow; }
        @Basic()
        @Column(name="\"controlPulseLow\"")
        private Double controlPulseLow ;
         
        /**
         * Unit response rate which specifies the active power change for a control
         * pulse of one second in the most responsive loading level of the unit.
         */
        public Double getControlResponseRate () { return controlResponseRate; }
        public void setControlResponseRate ( Double controlResponseRate ) { this.controlResponseRate = controlResponseRate; }
        @Basic()
        @Column(name="\"controlResponseRate\"")
        private Double controlResponseRate ;
         
        /**
         * The efficiency of the unit in converting mechanical energy, from the prime
         * mover, into electrical energy.
         */
        public Double getEfficiency () { return efficiency; }
        public void setEfficiency ( Double efficiency ) { this.efficiency = efficiency; }
        @Basic()
        @Column(name="\"efficiency\"")
        private Double efficiency ;
         
        /**
         * The unit control mode.
         */
        public String getGenControlMode () { return genControlMode; }
        public void setGenControlMode ( String genControlMode ) { this.genControlMode = genControlMode; }
        @Basic()
        @Column(name="\"genControlMode\"")
        private String genControlMode ;
         
        /**
         * The source of controls for a generating unit. Defines the control status
         * of the generating unit.
         */
        public String getGenControlSource () { return genControlSource; }
        public void setGenControlSource ( String genControlSource ) { this.genControlSource = genControlSource; }
        @Basic()
        @Column(name="\"genControlSource\"")
        private String genControlSource ;
         
        /**
         * Governor motor position limit.
         */
        public Double getGovernorMPL () { return governorMPL; }
        public void setGovernorMPL ( Double governorMPL ) { this.governorMPL = governorMPL; }
        @Basic()
        @Column(name="\"governorMPL\"")
        private Double governorMPL ;
         
        /**
         * Governor Speed Changer Droop. This is the change in generator power output
         * divided by the change in frequency normalized by the nominal power of the
         * generator and the nominal frequency and expressed in percent and negated.
         * A positive value of speed change droop provides additional generator output
         * upon a drop in frequency.
         */
        public Double getGovernorSCD () { return governorSCD; }
        public void setGovernorSCD ( Double governorSCD ) { this.governorSCD = governorSCD; }
        @Basic()
        @Column(name="\"governorSCD\"")
        private Double governorSCD ;
         
        /**
         * High limit for secondary (AGC) control.
         */
        public Double getHighControlLimit () { return highControlLimit; }
        public void setHighControlLimit ( Double highControlLimit ) { this.highControlLimit = highControlLimit; }
        @Basic()
        @Column(name="\"highControlLimit\"")
        private Double highControlLimit ;
         
        /**
         * Default initial active power which is used to store a powerflow result
         * for the initial active power for this unit in this network configuration.
         */
        public Double getInitialP () { return initialP; }
        public void setInitialP ( Double initialP ) { this.initialP = initialP; }
        @Basic()
        @Column(name="\"initialP\"")
        private Double initialP ;
         
        /**
         * Generating unit long term economic participation factor.
         */
        public Double getLongPF () { return longPF; }
        public void setLongPF ( Double longPF ) { this.longPF = longPF; }
        @Basic()
        @Column(name="\"longPF\"")
        private Double longPF ;
         
        /**
         * Low limit for secondary (AGC) control.
         */
        public Double getLowControlLimit () { return lowControlLimit; }
        public void setLowControlLimit ( Double lowControlLimit ) { this.lowControlLimit = lowControlLimit; }
        @Basic()
        @Column(name="\"lowControlLimit\"")
        private Double lowControlLimit ;
         
        /**
         * The normal maximum rate the generating unit active power output can be
         * lowered by control actions.
         */
        public Double getLowerRampRate () { return lowerRampRate; }
        public void setLowerRampRate ( Double lowerRampRate ) { this.lowerRampRate = lowerRampRate; }
        @Basic()
        @Column(name="\"lowerRampRate\"")
        private Double lowerRampRate ;
         
        /**
         * Maximum high economic active power limit, that should not exceed the maximum
         * operating active power limit.
         */
        public Double getMaxEconomicP () { return maxEconomicP; }
        public void setMaxEconomicP ( Double maxEconomicP ) { this.maxEconomicP = maxEconomicP; }
        @Basic()
        @Column(name="\"maxEconomicP\"")
        private Double maxEconomicP ;
         
        /**
         * Maximum allowable spinning reserve. Spinning reserve will never be considered
         * greater than this value regardless of the current operating point.
         */
        public Double getMaximumAllowableSpinningReserve () { return maximumAllowableSpinningReserve; }
        public void setMaximumAllowableSpinningReserve ( Double maximumAllowableSpinningReserve ) { this.maximumAllowableSpinningReserve = maximumAllowableSpinningReserve; }
        @Basic()
        @Column(name="\"maximumAllowableSpinningReserve\"")
        private Double maximumAllowableSpinningReserve ;
         
        /**
         * This is the maximum operating active power limit the dispatcher can enter
         * for this unit.
         */
        public Double getMaxOperatingP () { return maxOperatingP; }
        public void setMaxOperatingP ( Double maxOperatingP ) { this.maxOperatingP = maxOperatingP; }
        @Basic()
        @Column(name="\"maxOperatingP\"")
        private Double maxOperatingP ;
         
        /**
         * Low economic active power limit that shall be greater than or equal to
         * the minimum operating active power limit.
         */
        public Double getMinEconomicP () { return minEconomicP; }
        public void setMinEconomicP ( Double minEconomicP ) { this.minEconomicP = minEconomicP; }
        @Basic()
        @Column(name="\"minEconomicP\"")
        private Double minEconomicP ;
         
        /**
         * Minimum time interval between unit shutdown and startup.
         */
        public Double getMinimumOffTime () { return minimumOffTime; }
        public void setMinimumOffTime ( Double minimumOffTime ) { this.minimumOffTime = minimumOffTime; }
        @Basic()
        @Column(name="\"minimumOffTime\"")
        private Double minimumOffTime ;
         
        /**
         * This is the minimum operating active power limit the dispatcher can enter
         * for this unit.
         */
        public Double getMinOperatingP () { return minOperatingP; }
        public void setMinOperatingP ( Double minOperatingP ) { this.minOperatingP = minOperatingP; }
        @Basic()
        @Column(name="\"minOperatingP\"")
        private Double minOperatingP ;
         
        /**
         * Detail level of the generator model data.
         */
        public Integer getModelDetail () { return modelDetail; }
        public void setModelDetail ( Integer modelDetail ) { this.modelDetail = modelDetail; }
        @Basic()
        @Column(name="\"modelDetail\"")
        private Integer modelDetail ;
         
        /**
         * The nominal power of the generating unit. Used to give precise meaning
         * to percentage based attributes such as the governor speed change droop
         * (governorSCD attribute).
         * The attribute shall be a positive value equal to or less than RotatingMachine.ratedS.
         */
        public Double getNominalP () { return nominalP; }
        public void setNominalP ( Double nominalP ) { this.nominalP = nominalP; }
        @Basic()
        @Column(name="\"nominalP\"")
        private Double nominalP ;
         
        /**
         * Generating unit economic participation factor. The sum of the participation
         * factors across generating units does not have to sum to one. It is used
         * for representing distributed slack participation factor. The attribute
         * shall be a positive value or zero.
         */
        public Double getNormalPF () { return normalPF; }
        public void setNormalPF ( Double normalPF ) { this.normalPF = normalPF; }
        @Basic()
        @Column(name="\"normalPF\"")
        private Double normalPF ;
         
        /**
         * Defined as: 1 / ( 1 - Incremental Transmission Loss); with the Incremental
         * Transmission Loss expressed as a plus or minus value. The typical range
         * of penalty factors is (0.9 to 1.1).
         */
        public Double getPenaltyFactor () { return penaltyFactor; }
        public void setPenaltyFactor ( Double penaltyFactor ) { this.penaltyFactor = penaltyFactor; }
        @Basic()
        @Column(name="\"penaltyFactor\"")
        private Double penaltyFactor ;
         
        /**
         * The normal maximum rate the generating unit active power output can be
         * raised by control actions.
         */
        public Double getRaiseRampRate () { return raiseRampRate; }
        public void setRaiseRampRate ( Double raiseRampRate ) { this.raiseRampRate = raiseRampRate; }
        @Basic()
        @Column(name="\"raiseRampRate\"")
        private Double raiseRampRate ;
         
        /**
         * The unit's gross rated maximum capacity (book value).
         * The attribute shall be a positive value.
         */
        public Double getRatedGrossMaxP () { return ratedGrossMaxP; }
        public void setRatedGrossMaxP ( Double ratedGrossMaxP ) { this.ratedGrossMaxP = ratedGrossMaxP; }
        @Basic()
        @Column(name="\"ratedGrossMaxP\"")
        private Double ratedGrossMaxP ;
         
        /**
         * The gross rated minimum generation level which the unit can safely operate
         * at while delivering power to the transmission grid.
         * The attribute shall be a positive value.
         */
        public Double getRatedGrossMinP () { return ratedGrossMinP; }
        public void setRatedGrossMinP ( Double ratedGrossMinP ) { this.ratedGrossMinP = ratedGrossMinP; }
        @Basic()
        @Column(name="\"ratedGrossMinP\"")
        private Double ratedGrossMinP ;
         
        /**
         * The net rated maximum capacity determined by subtracting the auxiliary
         * power used to operate the internal plant machinery from the rated gross
         * maximum capacity.
         * The attribute shall be a positive value.
         */
        public Double getRatedNetMaxP () { return ratedNetMaxP; }
        public void setRatedNetMaxP ( Double ratedNetMaxP ) { this.ratedNetMaxP = ratedNetMaxP; }
        @Basic()
        @Column(name="\"ratedNetMaxP\"")
        private Double ratedNetMaxP ;
         
        /**
         * Generating unit short term economic participation factor.
         */
        public Double getShortPF () { return shortPF; }
        public void setShortPF ( Double shortPF ) { this.shortPF = shortPF; }
        @Basic()
        @Column(name="\"shortPF\"")
        private Double shortPF ;
         
        /**
         * The initial startup cost incurred for each start of the GeneratingUnit.
         */
        public String getStartupCost () { return startupCost; }
        public void setStartupCost ( String startupCost ) { this.startupCost = startupCost; }
        @Basic()
        @Column(name="\"startupCost\"")
        private String startupCost ;
         
        /**
         * Time it takes to get the unit on-line, from the time that the prime mover
         * mechanical power is applied.
         */
        public Double getStartupTime () { return startupTime; }
        public void setStartupTime ( Double startupTime ) { this.startupTime = startupTime; }
        @Basic()
        @Column(name="\"startupTime\"")
        private Double startupTime ;
         
        /**
         * Generating unit economic participation factor.
         */
        public Double getTieLinePF () { return tieLinePF; }
        public void setTieLinePF ( Double tieLinePF ) { this.tieLinePF = tieLinePF; }
        @Basic()
        @Column(name="\"tieLinePF\"")
        private Double tieLinePF ;
         
        /**
         * The efficiency of the unit in converting the fuel into electrical energy.
         */
        public Double getTotalEfficiency () { return totalEfficiency; }
        public void setTotalEfficiency ( Double totalEfficiency ) { this.totalEfficiency = totalEfficiency; }
        @Basic()
        @Column(name="\"totalEfficiency\"")
        private Double totalEfficiency ;
         
        /**
         * The variable cost component of production per unit of ActivePower.
         */
        public String getVariableCost () { return variableCost; }
        public void setVariableCost ( String variableCost ) { this.variableCost = variableCost; }
        @Basic()
        @Column(name="\"variableCost\"")
        private String variableCost ;
         
        /**
         * A generating unit may have an operating schedule, indicating the planned
         * operation of the unit.
         */
        public GenUnitOpSchedule getGenUnitOpSchedule () { return genUnitOpSchedule; }
        public void setGenUnitOpSchedule ( GenUnitOpSchedule genUnitOpSchedule ) { this.genUnitOpSchedule = genUnitOpSchedule; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GenUnitOpSchedule\"")
        private GenUnitOpSchedule genUnitOpSchedule ;
         
    }
     
    /**
     * Unit control modes.
     */
    @Entity
    @Table(name="\"GeneratorControlMode\"")
    public static class GeneratorControlMode
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * Unit control modes.
     */
    @Entity
    @Table(name="\"GeneratorControlMode1\"")
    public static class GeneratorControlMode1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The source of controls for a generating unit.
     */
    @Entity
    @Table(name="\"GeneratorControlSource\"")
    public static class GeneratorControlSource
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
     
    /**
     * The source of controls for a generating unit.
     */
    @Entity
    @Table(name="\"GeneratorControlSource1\"")
    public static class GeneratorControlSource1
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Relationship between the generating unit's gross active power output on
     * the X-axis (measured at the terminals of the machine(s)) and the generating
     * unit's net active power output on the Y-axis (based on utility-defined
     * measurements at the power station). Station service loads, when modelled,
     * should be treated as non-conforming bus loads. There may be more than one
     * curve, depending on the auxiliary equipment that is in service.
     */
    @Entity
    @Table(name="\"GrossToNetActivePowerCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class GrossToNetActivePowerCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A generating unit may have a gross active power to net active power curve,
         * describing the losses and auxiliary power requirements of the unit.
         */
        public GeneratingUnit getGeneratingUnit () { return generatingUnit; }
        public void setGeneratingUnit ( GeneratingUnit generatingUnit ) { this.generatingUnit = generatingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GeneratingUnit\"")
        private GeneratingUnit generatingUnit ;
         
    }
    /**
     * Relationship between unit heat input in energy per time for main fuel (Y1-axis)
     * and supplemental fuel (Y2-axis) versus unit output in active power (X-axis).
     * The quantity of main fuel used to sustain generation at this output level
     * is prorated for throttling between definition points. The quantity of supplemental
     * fuel used at this output level is fixed and not prorated.
     */
    @Entity
    @Table(name="\"HeatInputCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HeatInputCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Power output - auxiliary power multiplier adjustment factor.
         */
        public Double getAuxPowerMult () { return auxPowerMult; }
        public void setAuxPowerMult ( Double auxPowerMult ) { this.auxPowerMult = auxPowerMult; }
        @Basic()
        @Column(name="\"auxPowerMult\"")
        private Double auxPowerMult ;
         
        /**
         * Power output - auxiliary power offset adjustment factor.
         */
        public Double getAuxPowerOffset () { return auxPowerOffset; }
        public void setAuxPowerOffset ( Double auxPowerOffset ) { this.auxPowerOffset = auxPowerOffset; }
        @Basic()
        @Column(name="\"auxPowerOffset\"")
        private Double auxPowerOffset ;
         
        /**
         * Heat input - efficiency multiplier adjustment factor.
         */
        public Double getHeatInputEff () { return heatInputEff; }
        public void setHeatInputEff ( Double heatInputEff ) { this.heatInputEff = heatInputEff; }
        @Basic()
        @Column(name="\"heatInputEff\"")
        private Double heatInputEff ;
         
        /**
         * Heat input - offset adjustment factor.
         */
        public Double getHeatInputOffset () { return heatInputOffset; }
        public void setHeatInputOffset ( Double heatInputOffset ) { this.heatInputOffset = heatInputOffset; }
        @Basic()
        @Column(name="\"heatInputOffset\"")
        private Double heatInputOffset ;
         
        /**
         * Flag is set to true when output is expressed in net active power.
         */
        public Boolean getIsNetGrossP () { return isNetGrossP; }
        public void setIsNetGrossP ( Boolean isNetGrossP ) { this.isNetGrossP = isNetGrossP; }
        @Basic()
        @Column(name="\"isNetGrossP\"")
        private Boolean isNetGrossP ;
         
        /**
         * A thermal generating unit may have a heat input curve.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
    /**
     * Relationship between unit heat rate per active power (Y-axis) and unit
     * output (X-axis). The heat input is from all fuels.
     */
    @Entity
    @Table(name="\"HeatRateCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HeatRateCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Flag is set to true when output is expressed in net active power.
         */
        public Boolean getIsNetGrossP () { return isNetGrossP; }
        public void setIsNetGrossP ( Boolean isNetGrossP ) { this.isNetGrossP = isNetGrossP; }
        @Basic()
        @Column(name="\"isNetGrossP\"")
        private Boolean isNetGrossP ;
         
        /**
         * A thermal generating unit may have a heat rate curve.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
     
    /**
     * Specifies the capability of the hydro generating unit to convert energy
     * as a generator or pump.
     */
    @Entity
    @Table(name="\"HydroEnergyConversionKind\"")
    public static class HydroEnergyConversionKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Relationship between unit efficiency as percentage and unit output active
     * power for a given net head in meters. The relationship between efficiency,
     * discharge, head, and power output is expressed as follows: E =KP/HQ
     * where: E is the efficiency, as a percentage; P is the active power; H is
     * the height; Q is the discharge, volume/time unit; K is a constant.
     * For example, a curve instance for a given net head could show efficiency
     * (Y-axis) versus active power output (X-axis) or versus discharge on the
     * X-axis.
     */
    @Entity
    @Table(name="\"HydroGeneratingEfficiencyCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroGeneratingEfficiencyCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A hydro generating unit has an efficiency curve.
         */
        public HydroGeneratingUnit getHydroGeneratingUnit () { return hydroGeneratingUnit; }
        public void setHydroGeneratingUnit ( HydroGeneratingUnit hydroGeneratingUnit ) { this.hydroGeneratingUnit = hydroGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroGeneratingUnit\"")
        private HydroGeneratingUnit hydroGeneratingUnit ;
         
    }
    /**
     * A generating unit whose prime mover is a hydraulic turbine (e.g., Francis,
     * Pelton, Kaplan).
     */
    @Entity
    @Table(name="\"HydroGeneratingUnit\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroGeneratingUnit
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A generating unit whose prime mover is a hydraulic turbine (e.g., Francis,
     * Pelton, Kaplan).
     */
    @Entity
    @Table(name="\"HydroGeneratingUnit1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroGeneratingUnit1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The height water drops from the reservoir mid-point to the turbine.
         */
        public Double getDropHeight () { return dropHeight; }
        public void setDropHeight ( Double dropHeight ) { this.dropHeight = dropHeight; }
        @Basic()
        @Column(name="\"dropHeight\"")
        private Double dropHeight ;
         
        /**
         * Energy conversion capability for generating.
         */
        public String getEnergyConversionCapability () { return energyConversionCapability; }
        public void setEnergyConversionCapability ( String energyConversionCapability ) { this.energyConversionCapability = energyConversionCapability; }
        @Basic()
        @Column(name="\"energyConversionCapability\"")
        private String energyConversionCapability ;
         
        /**
         * The equivalent cost of water that drives the hydro turbine.
         */
        public Double getHydroUnitWaterCost () { return hydroUnitWaterCost; }
        public void setHydroUnitWaterCost ( Double hydroUnitWaterCost ) { this.hydroUnitWaterCost = hydroUnitWaterCost; }
        @Basic()
        @Column(name="\"hydroUnitWaterCost\"")
        private Double hydroUnitWaterCost ;
         
        /**
         * Type of turbine.
         */
        public String getTurbineType () { return turbineType; }
        public void setTurbineType ( String turbineType ) { this.turbineType = turbineType; }
        @Basic()
        @Column(name="\"turbineType\"")
        private String turbineType ;
         
        /**
         * The hydro generating unit belongs to a hydro power plant.
         */
        public HydroPowerPlant getHydroPowerPlant () { return hydroPowerPlant; }
        public void setHydroPowerPlant ( HydroPowerPlant hydroPowerPlant ) { this.hydroPowerPlant = hydroPowerPlant; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroPowerPlant\"")
        private HydroPowerPlant hydroPowerPlant ;
         
        /**
         * A hydro generating unit has a penstock loss curve.
         */
        public PenstockLossCurve getPenstockLossCurve () { return penstockLossCurve; }
        public void setPenstockLossCurve ( PenstockLossCurve penstockLossCurve ) { this.penstockLossCurve = penstockLossCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PenstockLossCurve\"")
        private PenstockLossCurve penstockLossCurve ;
         
    }
     
    /**
     * The type of hydro power plant.
     */
    @Entity
    @Table(name="\"HydroPlantStorageKind\"")
    public static class HydroPlantStorageKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A hydro power station which can generate or pump. When generating, the
     * generator turbines receive water from an upper reservoir. When pumping,
     * the pumps receive their water from a lower reservoir.
     */
    @Entity
    @Table(name="\"HydroPowerPlant\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroPowerPlant
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A hydro power station which can generate or pump. When generating, the
     * generator turbines receive water from an upper reservoir. When pumping,
     * the pumps receive their water from a lower reservoir.
     */
    @Entity
    @Table(name="\"HydroPowerPlant1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroPowerPlant1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Water travel delay from tailbay to next downstream hydro power station.
         */
        public Double getDischargeTravelDelay () { return dischargeTravelDelay; }
        public void setDischargeTravelDelay ( Double dischargeTravelDelay ) { this.dischargeTravelDelay = dischargeTravelDelay; }
        @Basic()
        @Column(name="\"dischargeTravelDelay\"")
        private Double dischargeTravelDelay ;
         
        /**
         * The hydro plant's generating rating active power for rated head conditions.
         * The attribute shall be a positive value.
         */
        public Double getGenRatedP () { return genRatedP; }
        public void setGenRatedP ( Double genRatedP ) { this.genRatedP = genRatedP; }
        @Basic()
        @Column(name="\"genRatedP\"")
        private Double genRatedP ;
         
        /**
         * The type of hydro power plant water storage.
         */
        public String getHydroPlantStorageType () { return hydroPlantStorageType; }
        public void setHydroPlantStorageType ( String hydroPlantStorageType ) { this.hydroPlantStorageType = hydroPlantStorageType; }
        @Basic()
        @Column(name="\"hydroPlantStorageType\"")
        private String hydroPlantStorageType ;
         
        /**
         * Type and configuration of hydro plant penstock(s).
         */
        public String getPenstockType () { return penstockType; }
        public void setPenstockType ( String penstockType ) { this.penstockType = penstockType; }
        @Basic()
        @Column(name="\"penstockType\"")
        private String penstockType ;
         
        /**
         * Total plant discharge capacity.
         */
        public Double getPlantDischargeCapacity () { return plantDischargeCapacity; }
        public void setPlantDischargeCapacity ( Double plantDischargeCapacity ) { this.plantDischargeCapacity = plantDischargeCapacity; }
        @Basic()
        @Column(name="\"plantDischargeCapacity\"")
        private Double plantDischargeCapacity ;
         
        /**
         * The plant's rated gross head.
         * The attribute shall be a positive value.
         */
        public Double getPlantRatedHead () { return plantRatedHead; }
        public void setPlantRatedHead ( Double plantRatedHead ) { this.plantRatedHead = plantRatedHead; }
        @Basic()
        @Column(name="\"plantRatedHead\"")
        private Double plantRatedHead ;
         
        /**
         * The hydro plant's pumping rating active power for rated head conditions.
         * The attribute shall be a positive value.
         */
        public Double getPumpRatedP () { return pumpRatedP; }
        public void setPumpRatedP ( Double pumpRatedP ) { this.pumpRatedP = pumpRatedP; }
        @Basic()
        @Column(name="\"pumpRatedP\"")
        private Double pumpRatedP ;
         
        /**
         * A code describing the type (or absence) of surge tank that is associated
         * with the hydro power plant.
         */
        public String getSurgeTankCode () { return surgeTankCode; }
        public void setSurgeTankCode ( String surgeTankCode ) { this.surgeTankCode = surgeTankCode; }
        @Basic()
        @Column(name="\"surgeTankCode\"")
        private String surgeTankCode ;
         
        /**
         * The level at which the surge tank spills.
         */
        public Double getSurgeTankCrestLevel () { return surgeTankCrestLevel; }
        public void setSurgeTankCrestLevel ( Double surgeTankCrestLevel ) { this.surgeTankCrestLevel = surgeTankCrestLevel; }
        @Basic()
        @Column(name="\"surgeTankCrestLevel\"")
        private Double surgeTankCrestLevel ;
         
        /**
         * Generators are supplied water from or pumps discharge water to an upstream
         * reservoir.
         */
        public Reservoir getGenSourcePumpDischargeReservoir () { return genSourcePumpDischargeReservoir; }
        public void setGenSourcePumpDischargeReservoir ( Reservoir genSourcePumpDischargeReservoir ) { this.genSourcePumpDischargeReservoir = genSourcePumpDischargeReservoir; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"GenSourcePumpDischargeReservoir\"")
        private Reservoir genSourcePumpDischargeReservoir ;
         
        /**
         * Generators discharge water to or pumps are supplied water from a downstream
         * reservoir.
         */
        public Reservoir getReservoir () { return reservoir; }
        public void setReservoir ( Reservoir reservoir ) { this.reservoir = reservoir; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Reservoir\"")
        private Reservoir reservoir ;
         
    }
    /**
     * A synchronous motor-driven pump, typically associated with a pumped storage
     * plant.
     */
    @Entity
    @Table(name="\"HydroPump\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroPump
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The pumping discharge under maximum head conditions, usually at full gate.
         */
        public Double getPumpDischAtMaxHead () { return pumpDischAtMaxHead; }
        public void setPumpDischAtMaxHead ( Double pumpDischAtMaxHead ) { this.pumpDischAtMaxHead = pumpDischAtMaxHead; }
        @Basic()
        @Column(name="\"pumpDischAtMaxHead\"")
        private Double pumpDischAtMaxHead ;
         
        /**
         * The pumping discharge under minimum head conditions, usually at full gate.
         */
        public Double getPumpDischAtMinHead () { return pumpDischAtMinHead; }
        public void setPumpDischAtMinHead ( Double pumpDischAtMinHead ) { this.pumpDischAtMinHead = pumpDischAtMinHead; }
        @Basic()
        @Column(name="\"pumpDischAtMinHead\"")
        private Double pumpDischAtMinHead ;
         
        /**
         * The pumping power under maximum head conditions, usually at full gate.
         */
        public Double getPumpPowerAtMaxHead () { return pumpPowerAtMaxHead; }
        public void setPumpPowerAtMaxHead ( Double pumpPowerAtMaxHead ) { this.pumpPowerAtMaxHead = pumpPowerAtMaxHead; }
        @Basic()
        @Column(name="\"pumpPowerAtMaxHead\"")
        private Double pumpPowerAtMaxHead ;
         
        /**
         * The pumping power under minimum head conditions, usually at full gate.
         */
        public Double getPumpPowerAtMinHead () { return pumpPowerAtMinHead; }
        public void setPumpPowerAtMinHead ( Double pumpPowerAtMinHead ) { this.pumpPowerAtMinHead = pumpPowerAtMinHead; }
        @Basic()
        @Column(name="\"pumpPowerAtMinHead\"")
        private Double pumpPowerAtMinHead ;
         
        /**
         * The hydro pump may be a member of a pumped storage plant or a pump for
         * distributing water.
         */
        public HydroPowerPlant getHydroPowerPlant () { return hydroPowerPlant; }
        public void setHydroPowerPlant ( HydroPowerPlant hydroPowerPlant ) { this.hydroPowerPlant = hydroPowerPlant; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroPowerPlant\"")
        private HydroPowerPlant hydroPowerPlant ;
         
        /**
         * The hydro pump has a pumping schedule over time, indicating when pumping
         * is to occur.
         */
        public HydroPumpOpSchedule getHydroPumpOpSchedule () { return hydroPumpOpSchedule; }
        public void setHydroPumpOpSchedule ( HydroPumpOpSchedule hydroPumpOpSchedule ) { this.hydroPumpOpSchedule = hydroPumpOpSchedule; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroPumpOpSchedule\"")
        private HydroPumpOpSchedule hydroPumpOpSchedule ;
         
        /**
         * The synchronous machine drives the turbine which moves the water from a
         * low elevation to a higher elevation. The direction of machine rotation
         * for pumping may or may not be the same as for generating.
         */
        public RotatingMachine getRotatingMachine () { return rotatingMachine; }
        public void setRotatingMachine ( RotatingMachine rotatingMachine ) { this.rotatingMachine = rotatingMachine; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"RotatingMachine\"")
        private RotatingMachine rotatingMachine ;
         
    }
    /**
     * The hydro pump's Operator-approved current operating schedule (or plan),
     * typically produced with the aid of unit commitment type analyses. The unit's
     * operating schedule status is typically given as: (0=unavailable) (1=available
     * to startup or shutdown) (2=must pump).
     */
    @Entity
    @Table(name="\"HydroPumpOpSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroPumpOpSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * The hydro pump's Operator-approved current operating schedule (or plan),
     * typically produced with the aid of unit commitment type analyses. The unit's
     * operating schedule status is typically given as: (0=unavailable) (1=available
     * to startup or shutdown) (2=must pump).
     */
    @Entity
    @Table(name="\"HydroPumpOpSchedule1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class HydroPumpOpSchedule1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The hydro pump has a pumping schedule over time, indicating when pumping
         * is to occur.
         */
        public HydroPump getHydroPump () { return hydroPump; }
        public void setHydroPump ( HydroPump hydroPump ) { this.hydroPump = hydroPump; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroPump\"")
        private HydroPump hydroPump ;
         
    }
     
    /**
     * Type of turbine.
     */
    @Entity
    @Table(name="\"HydroTurbineKind\"")
    public static class HydroTurbineKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * Relationship between unit incremental heat rate in (delta energy/time)
     * per (delta active power) and unit output in active power. The IHR curve
     * represents the slope of the HeatInputCurve. Note that the "incremental
     * heat rate" and the "heat rate" have the same engineering units.
     */
    @Entity
    @Table(name="\"IncrementalHeatRateCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class IncrementalHeatRateCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Flag is set to true when output is expressed in net active power.
         */
        public Boolean getIsNetGrossP () { return isNetGrossP; }
        public void setIsNetGrossP ( Boolean isNetGrossP ) { this.isNetGrossP = isNetGrossP; }
        @Basic()
        @Column(name="\"isNetGrossP\"")
        private Boolean isNetGrossP ;
         
        /**
         * A thermal generating unit may have an incremental heat rate curve.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
    /**
     * Natural water inflow to a reservoir, usually forecasted from predicted
     * rain and snowmelt. Typically in one hour increments for up to 10 days.
     * The forecast is given in average cubic meters per second over the time
     * increment.
     */
    @Entity
    @Table(name="\"InflowForecast\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class InflowForecast
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A reservoir may have a "natural" inflow forecast.
         */
        public Reservoir getReservoir () { return reservoir; }
        public void setReservoir ( Reservoir reservoir ) { this.reservoir = reservoir; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Reservoir\"")
        private Reservoir reservoir ;
         
    }
    /**
     * Relationship between reservoir volume and reservoir level. The volume is
     * at the Y-axis and the reservoir level at the X-axis.
     */
    @Entity
    @Table(name="\"LevelVsVolumeCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class LevelVsVolumeCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A reservoir may have a level versus volume relationship.
         */
        public Reservoir getReservoir () { return reservoir; }
        public void setReservoir ( Reservoir reservoir ) { this.reservoir = reservoir; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Reservoir\"")
        private Reservoir reservoir ;
         
    }
    /**
     * A nuclear generating unit.
     */
    @Entity
    @Table(name="\"NuclearGeneratingUnit\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class NuclearGeneratingUnit extends GeneratingUnit
    {
    }
    /**
     * Relationship between penstock head loss (in meters) and total discharge
     * through the penstock (in cubic meters per second). One or more turbines
     * may be connected to the same penstock.
     */
    @Entity
    @Table(name="\"PenstockLossCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PenstockLossCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Relationship between penstock head loss (in meters) and total discharge
     * through the penstock (in cubic meters per second). One or more turbines
     * may be connected to the same penstock.
     */
    @Entity
    @Table(name="\"PenstockLossCurve1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PenstockLossCurve1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A hydro generating unit has a penstock loss curve.
         */
        public HydroGeneratingUnit getHydroGeneratingUnit () { return hydroGeneratingUnit; }
        public void setHydroGeneratingUnit ( HydroGeneratingUnit hydroGeneratingUnit ) { this.hydroGeneratingUnit = hydroGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroGeneratingUnit\"")
        private HydroGeneratingUnit hydroGeneratingUnit ;
         
    }
    /**
     * A photovoltaic device or an aggregation of such devices.
     */
    @Entity
    @Table(name="\"PhotoVoltaicUnit\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PhotoVoltaicUnit extends PowerElectronicsUnit
    {
    }
    /**
     * A connection to the AC network for energy production or consumption that
     * uses power electronics rather than rotating machines.
     */
    @Entity
    @Table(name="\"PowerElectronicsConnection\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerElectronicsConnection
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A generating unit or battery or aggregation that connects to the AC network
     * using power electronics rather than rotating machines.
     */
    @Entity
    @Table(name="\"PowerElectronicsUnit\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class PowerElectronicsUnit
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Maximum active power limit. This is the maximum (nameplate) limit for the
         * unit.
         */
        public Double getMaxP () { return maxP; }
        public void setMaxP ( Double maxP ) { this.maxP = maxP; }
        @Basic()
        @Column(name="\"maxP\"")
        private Double maxP ;
         
        /**
         * Minimum active power limit. This is the minimum (nameplate) limit for the
         * unit.
         */
        public Double getMinP () { return minP; }
        public void setMinP ( Double minP ) { this.minP = minP; }
        @Basic()
        @Column(name="\"minP\"")
        private Double minP ;
         
        /**
         * A power electronics unit has a connection to the AC network.
         */
        public PowerElectronicsConnection getPowerElectronicsConnection () { return powerElectronicsConnection; }
        public void setPowerElectronicsConnection ( PowerElectronicsConnection powerElectronicsConnection ) { this.powerElectronicsConnection = powerElectronicsConnection; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"PowerElectronicsConnection\"")
        private PowerElectronicsConnection powerElectronicsConnection ;
         
    }
    /**
     * A wind generating unit that connects to the AC network with power electronics
     * rather than rotating machines or an aggregation of such units.
     */
    @Entity
    @Table(name="\"PowerElectronicsWindUnit\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class PowerElectronicsWindUnit extends PowerElectronicsUnit
    {
    }
    /**
     * A water storage facility within a hydro system, including: ponds, lakes,
     * lagoons, and rivers. The storage is usually behind some type of dam.
     */
    @Entity
    @Table(name="\"Reservoir\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Reservoir
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * A water storage facility within a hydro system, including: ponds, lakes,
     * lagoons, and rivers. The storage is usually behind some type of dam.
     */
    @Entity
    @Table(name="\"Reservoir1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class Reservoir1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Storage volume between the full supply level and the normal minimum operating
         * level.
         */
        public Double getActiveStorageCapacity () { return activeStorageCapacity; }
        public void setActiveStorageCapacity ( Double activeStorageCapacity ) { this.activeStorageCapacity = activeStorageCapacity; }
        @Basic()
        @Column(name="\"activeStorageCapacity\"")
        private Double activeStorageCapacity ;
         
        /**
         * The reservoir's energy storage rating in energy for given head conditions.
         */
        public Double getEnergyStorageRating () { return energyStorageRating; }
        public void setEnergyStorageRating ( Double energyStorageRating ) { this.energyStorageRating = energyStorageRating; }
        @Basic()
        @Column(name="\"energyStorageRating\"")
        private Double energyStorageRating ;
         
        /**
         * Full supply level, above which water will spill. This can be the spillway
         * crest level or the top of closed gates.
         */
        public Double getFullSupplyLevel () { return fullSupplyLevel; }
        public void setFullSupplyLevel ( Double fullSupplyLevel ) { this.fullSupplyLevel = fullSupplyLevel; }
        @Basic()
        @Column(name="\"fullSupplyLevel\"")
        private Double fullSupplyLevel ;
         
        /**
         * Total capacity of reservoir.
         */
        public Double getGrossCapacity () { return grossCapacity; }
        public void setGrossCapacity ( Double grossCapacity ) { this.grossCapacity = grossCapacity; }
        @Basic()
        @Column(name="\"grossCapacity\"")
        private Double grossCapacity ;
         
        /**
         * Normal minimum operating level below which the penstocks will draw air.
         */
        public Double getNormalMinOperateLevel () { return normalMinOperateLevel; }
        public void setNormalMinOperateLevel ( Double normalMinOperateLevel ) { this.normalMinOperateLevel = normalMinOperateLevel; }
        @Basic()
        @Column(name="\"normalMinOperateLevel\"")
        private Double normalMinOperateLevel ;
         
        /**
         * River outlet works for riparian right releases or other purposes.
         */
        public String getRiverOutletWorks () { return riverOutletWorks; }
        public void setRiverOutletWorks ( String riverOutletWorks ) { this.riverOutletWorks = riverOutletWorks; }
        @Basic()
        @Column(name="\"riverOutletWorks\"")
        private String riverOutletWorks ;
         
        /**
         * The spillway water travel delay to the next downstream reservoir.
         */
        public Double getSpillTravelDelay () { return spillTravelDelay; }
        public void setSpillTravelDelay ( Double spillTravelDelay ) { this.spillTravelDelay = spillTravelDelay; }
        @Basic()
        @Column(name="\"spillTravelDelay\"")
        private Double spillTravelDelay ;
         
        /**
         * The flow capacity of the spillway in cubic meters per second.
         */
        public Double getSpillwayCapacity () { return spillwayCapacity; }
        public void setSpillwayCapacity ( Double spillwayCapacity ) { this.spillwayCapacity = spillwayCapacity; }
        @Basic()
        @Column(name="\"spillwayCapacity\"")
        private Double spillwayCapacity ;
         
        /**
         * The length of the spillway crest.
         */
        public Double getSpillwayCrestLength () { return spillwayCrestLength; }
        public void setSpillwayCrestLength ( Double spillwayCrestLength ) { this.spillwayCrestLength = spillwayCrestLength; }
        @Basic()
        @Column(name="\"spillwayCrestLength\"")
        private Double spillwayCrestLength ;
         
        /**
         * Spillway crest level above which water will spill.
         */
        public Double getSpillwayCrestLevel () { return spillwayCrestLevel; }
        public void setSpillwayCrestLevel ( Double spillwayCrestLevel ) { this.spillwayCrestLevel = spillwayCrestLevel; }
        @Basic()
        @Column(name="\"spillwayCrestLevel\"")
        private Double spillwayCrestLevel ;
         
        /**
         * Type of spillway gate, including parameters.
         */
        public String getSpillWayGateType () { return spillWayGateType; }
        public void setSpillWayGateType ( String spillWayGateType ) { this.spillWayGateType = spillWayGateType; }
        @Basic()
        @Column(name="\"spillWayGateType\"")
        private String spillWayGateType ;
         
        /**
         * A reservoir may spill into a downstream reservoir.
         */
        public Reservoir getSpillsFromReservoir () { return spillsFromReservoir; }
        public void setSpillsFromReservoir ( Reservoir spillsFromReservoir ) { this.spillsFromReservoir = spillsFromReservoir; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"SpillsFromReservoir\"")
        private Reservoir spillsFromReservoir ;
         
        /**
         * A reservoir may have a water level target schedule.
         */
        public TargetLevelSchedule getTargetLevelSchedule () { return targetLevelSchedule; }
        public void setTargetLevelSchedule ( TargetLevelSchedule targetLevelSchedule ) { this.targetLevelSchedule = targetLevelSchedule; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"TargetLevelSchedule\"")
        private TargetLevelSchedule targetLevelSchedule ;
         
    }
    /**
     * A rotating machine which may be used as a generator or motor.
     */
    @Entity
    @Table(name="\"RotatingMachine\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class RotatingMachine
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Relationship between the rate in gross active power/minute (Y-axis) at
     * which a unit should be shutdown and its present gross MW output (X-axis).
     */
    @Entity
    @Table(name="\"ShutdownCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ShutdownCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Fixed shutdown cost.
         */
        public String getShutdownCost () { return shutdownCost; }
        public void setShutdownCost ( String shutdownCost ) { this.shutdownCost = shutdownCost; }
        @Basic()
        @Column(name="\"shutdownCost\"")
        private String shutdownCost ;
         
        /**
         * The date and time of the most recent generating unit shutdown.
         */
        public String getShutdownDate () { return shutdownDate; }
        public void setShutdownDate ( String shutdownDate ) { this.shutdownDate = shutdownDate; }
        @Basic()
        @Column(name="\"shutdownDate\"")
        private String shutdownDate ;
         
        /**
         * A thermal generating unit may have a shutdown curve.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
    /**
     * A solar thermal generating unit, connected to the grid by means of a rotating
     * machine. This class does not represent photovoltaic (PV) generation.
     */
    @Entity
    @Table(name="\"SolarGeneratingUnit\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class SolarGeneratingUnit extends GeneratingUnit
    {
    }
    /**
     * The quantity of ignition fuel (Y-axis) used to restart and repay the auxiliary
     * power consumed versus the number of hours (X-axis) the unit was off line.
     */
    @Entity
    @Table(name="\"StartIgnFuelCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class StartIgnFuelCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Type of ignition fuel.
         */
        public String getIgnitionFuelType () { return ignitionFuelType; }
        public void setIgnitionFuelType ( String ignitionFuelType ) { this.ignitionFuelType = ignitionFuelType; }
        @Basic()
        @Column(name="\"ignitionFuelType\"")
        private String ignitionFuelType ;
         
        /**
         * The unit's startup model may have a startup ignition fuel curve.
         */
        public StartupModel getStartupModel () { return startupModel; }
        public void setStartupModel ( StartupModel startupModel ) { this.startupModel = startupModel; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StartupModel\"")
        private StartupModel startupModel ;
         
    }
    /**
     * The quantity of main fuel (Y-axis) used to restart and repay the auxiliary
     * power consumed versus the number of hours (X-axis) the unit was off line.
     */
    @Entity
    @Table(name="\"StartMainFuelCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class StartMainFuelCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Type of main fuel.
         */
        public String getMainFuelType () { return mainFuelType; }
        public void setMainFuelType ( String mainFuelType ) { this.mainFuelType = mainFuelType; }
        @Basic()
        @Column(name="\"mainFuelType\"")
        private String mainFuelType ;
         
        /**
         * The unit's startup model may have a startup main fuel curve.
         */
        public StartupModel getStartupModel () { return startupModel; }
        public void setStartupModel ( StartupModel startupModel ) { this.startupModel = startupModel; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StartupModel\"")
        private StartupModel startupModel ;
         
    }
    /**
     * Rate in gross active power per minute (Y-axis) at which a unit can be loaded
     * versus the number of hours (X-axis) the unit was off line.
     */
    @Entity
    @Table(name="\"StartRampCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class StartRampCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * The startup ramp rate in gross for a unit that is on hot standby.
         */
        public Double getHotStandbyRamp () { return hotStandbyRamp; }
        public void setHotStandbyRamp ( Double hotStandbyRamp ) { this.hotStandbyRamp = hotStandbyRamp; }
        @Basic()
        @Column(name="\"hotStandbyRamp\"")
        private Double hotStandbyRamp ;
         
        /**
         * The unit's startup model may have a startup ramp curve.
         */
        public StartupModel getStartupModel () { return startupModel; }
        public void setStartupModel ( StartupModel startupModel ) { this.startupModel = startupModel; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StartupModel\"")
        private StartupModel startupModel ;
         
    }
    /**
     * Unit start up characteristics depending on how long the unit has been off
     * line.
     */
    @Entity
    @Table(name="\"StartupModel\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class StartupModel
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Unit start up characteristics depending on how long the unit has been off
     * line.
     */
    @Entity
    @Table(name="\"StartupModel1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class StartupModel1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Fixed maintenance cost.
         */
        public Double getFixedMaintCost () { return fixedMaintCost; }
        public void setFixedMaintCost ( Double fixedMaintCost ) { this.fixedMaintCost = fixedMaintCost; }
        @Basic()
        @Column(name="\"fixedMaintCost\"")
        private Double fixedMaintCost ;
         
        /**
         * The amount of heat input per time unit required for hot standby operation.
         */
        public Double getHotStandbyHeat () { return hotStandbyHeat; }
        public void setHotStandbyHeat ( Double hotStandbyHeat ) { this.hotStandbyHeat = hotStandbyHeat; }
        @Basic()
        @Column(name="\"hotStandbyHeat\"")
        private Double hotStandbyHeat ;
         
        /**
         * Incremental maintenance cost.
         */
        public Double getIncrementalMaintCost () { return incrementalMaintCost; }
        public void setIncrementalMaintCost ( Double incrementalMaintCost ) { this.incrementalMaintCost = incrementalMaintCost; }
        @Basic()
        @Column(name="\"incrementalMaintCost\"")
        private Double incrementalMaintCost ;
         
        /**
         * The minimum number of hours the unit must be down before restart.
         */
        public Double getMinimumDownTime () { return minimumDownTime; }
        public void setMinimumDownTime ( Double minimumDownTime ) { this.minimumDownTime = minimumDownTime; }
        @Basic()
        @Column(name="\"minimumDownTime\"")
        private Double minimumDownTime ;
         
        /**
         * The minimum number of hours the unit must be operating before being allowed
         * to shut down.
         */
        public Double getMinimumRunTime () { return minimumRunTime; }
        public void setMinimumRunTime ( Double minimumRunTime ) { this.minimumRunTime = minimumRunTime; }
        @Basic()
        @Column(name="\"minimumRunTime\"")
        private Double minimumRunTime ;
         
        /**
         * The opportunity cost associated with the return in monetary unit. This
         * represents the restart's "share" of the unit depreciation and risk of an
         * event which would damage the unit.
         */
        public String getRiskFactorCost () { return riskFactorCost; }
        public void setRiskFactorCost ( String riskFactorCost ) { this.riskFactorCost = riskFactorCost; }
        @Basic()
        @Column(name="\"riskFactorCost\"")
        private String riskFactorCost ;
         
        /**
         * Total miscellaneous start up costs.
         */
        public String getStartupCost () { return startupCost; }
        public void setStartupCost ( String startupCost ) { this.startupCost = startupCost; }
        @Basic()
        @Column(name="\"startupCost\"")
        private String startupCost ;
         
        /**
         * The date and time of the most recent generating unit startup.
         */
        public String getStartupDate () { return startupDate; }
        public void setStartupDate ( String startupDate ) { this.startupDate = startupDate; }
        @Basic()
        @Column(name="\"startupDate\"")
        private String startupDate ;
         
        /**
         * Startup priority within control area where lower numbers indicate higher
         * priorities. More than one unit in an area may be assigned the same priority.
         */
        public Integer getStartupPriority () { return startupPriority; }
        public void setStartupPriority ( Integer startupPriority ) { this.startupPriority = startupPriority; }
        @Basic()
        @Column(name="\"startupPriority\"")
        private Integer startupPriority ;
         
        /**
         * The unit's auxiliary active power consumption to maintain standby mode.
         */
        public Double getStbyAuxP () { return stbyAuxP; }
        public void setStbyAuxP ( Double stbyAuxP ) { this.stbyAuxP = stbyAuxP; }
        @Basic()
        @Column(name="\"stbyAuxP\"")
        private Double stbyAuxP ;
         
        /**
         * The unit's startup model may have a startup ignition fuel curve.
         */
        public StartIgnFuelCurve getStartIgnFuelCurve () { return startIgnFuelCurve; }
        public void setStartIgnFuelCurve ( StartIgnFuelCurve startIgnFuelCurve ) { this.startIgnFuelCurve = startIgnFuelCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StartIgnFuelCurve\"")
        private StartIgnFuelCurve startIgnFuelCurve ;
         
        /**
         * The unit's startup model may have a startup main fuel curve.
         */
        public StartMainFuelCurve getStartMainFuelCurve () { return startMainFuelCurve; }
        public void setStartMainFuelCurve ( StartMainFuelCurve startMainFuelCurve ) { this.startMainFuelCurve = startMainFuelCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StartMainFuelCurve\"")
        private StartMainFuelCurve startMainFuelCurve ;
         
        /**
         * The unit's startup model may have a startup ramp curve.
         */
        public StartRampCurve getStartRampCurve () { return startRampCurve; }
        public void setStartRampCurve ( StartRampCurve startRampCurve ) { this.startRampCurve = startRampCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StartRampCurve\"")
        private StartRampCurve startRampCurve ;
         
        /**
         * A thermal generating unit may have a startup model.
         */
        public ThermalGeneratingUnit getThermalGeneratingUnit () { return thermalGeneratingUnit; }
        public void setThermalGeneratingUnit ( ThermalGeneratingUnit thermalGeneratingUnit ) { this.thermalGeneratingUnit = thermalGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ThermalGeneratingUnit\"")
        private ThermalGeneratingUnit thermalGeneratingUnit ;
         
    }
    /**
     * The cogeneration plant's steam sendout schedule in volume per time unit.
     */
    @Entity
    @Table(name="\"SteamSendoutSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SteamSendoutSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * The cogeneration plant's steam sendout schedule in volume per time unit.
     */
    @Entity
    @Table(name="\"SteamSendoutSchedule1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class SteamSendoutSchedule1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A cogeneration plant has a steam sendout schedule.
         */
        public CogenerationPlant getCogenerationPlant () { return cogenerationPlant; }
        public void setCogenerationPlant ( CogenerationPlant cogenerationPlant ) { this.cogenerationPlant = cogenerationPlant; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CogenerationPlant\"")
        private CogenerationPlant cogenerationPlant ;
         
    }
    /**
     * Relationship between tailbay head loss height (Y-axis) and the total discharge
     * into the power station's tailbay volume per time unit (X-axis) . There
     * could be more than one curve depending on the level of the tailbay reservoir
     * or river level.
     */
    @Entity
    @Table(name="\"TailbayLossCurve\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TailbayLossCurve
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * A hydro generating unit has a tailbay loss curve.
         */
        public HydroGeneratingUnit getHydroGeneratingUnit () { return hydroGeneratingUnit; }
        public void setHydroGeneratingUnit ( HydroGeneratingUnit hydroGeneratingUnit ) { this.hydroGeneratingUnit = hydroGeneratingUnit; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HydroGeneratingUnit\"")
        private HydroGeneratingUnit hydroGeneratingUnit ;
         
    }
    /**
     * Reservoir water level targets from advanced studies or "rule curves". Typically
     * in one hour increments for up to 10 days.
     */
    @Entity
    @Table(name="\"TargetLevelSchedule\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TargetLevelSchedule
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
    }
    /**
     * Reservoir water level targets from advanced studies or "rule curves". Typically
     * in one hour increments for up to 10 days.
     */
    @Entity
    @Table(name="\"TargetLevelSchedule1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class TargetLevelSchedule1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * High target level limit, above which the reservoir operation will be penalized.
         */
        public Double getHighLevelLimit () { return highLevelLimit; }
        public void setHighLevelLimit ( Double highLevelLimit ) { this.highLevelLimit = highLevelLimit; }
        @Basic()
        @Column(name="\"highLevelLimit\"")
        private Double highLevelLimit ;
         
        /**
         * Low target level limit, below which the reservoir operation will be penalized.
         */
        public Double getLowLevelLimit () { return lowLevelLimit; }
        public void setLowLevelLimit ( Double lowLevelLimit ) { this.lowLevelLimit = lowLevelLimit; }
        @Basic()
        @Column(name="\"lowLevelLimit\"")
        private Double lowLevelLimit ;
         
        /**
         * A reservoir may have a water level target schedule.
         */
        public Reservoir getReservoir () { return reservoir; }
        public void setReservoir ( Reservoir reservoir ) { this.reservoir = reservoir; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"Reservoir\"")
        private Reservoir reservoir ;
         
    }
    /**
     * A generating unit whose prime mover could be a steam turbine, combustion
     * turbine, or diesel engine.
     */
    @Entity
    @Table(name="\"ThermalGeneratingUnit\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class ThermalGeneratingUnit extends GeneratingUnit
    {
    }
    /**
     * A generating unit whose prime mover could be a steam turbine, combustion
     * turbine, or diesel engine.
     */
    @Entity
    @Table(name="\"ThermalGeneratingUnit1\"")
    @Inheritance(strategy=InheritanceType.JOINED)
    public static class ThermalGeneratingUnit1
    {
        public String getMRID () { return mRID; }
        public void setMRID ( String mRID ) { this.mRID = mRID; }
        @Id
        @Column(name="\"mRID\"")
        private String mRID ;
         
        /**
         * Operating and maintenance cost for the thermal unit.
         */
        public Double getOMCost () { return oMCost; }
        public void setOMCost ( Double oMCost ) { this.oMCost = oMCost; }
        @Basic()
        @Column(name="\"oMCost\"")
        private Double oMCost ;
         
        /**
         * A thermal generating unit may be a member of a compressed air energy storage
         * plant.
         */
        public CAESPlant getCAESPlant () { return cAESPlant; }
        public void setCAESPlant ( CAESPlant cAESPlant ) { this.cAESPlant = cAESPlant; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CAESPlant\"")
        private CAESPlant cAESPlant ;
         
        /**
         * A thermal generating unit may be a member of a cogeneration plant.
         */
        public CogenerationPlant getCogenerationPlant () { return cogenerationPlant; }
        public void setCogenerationPlant ( CogenerationPlant cogenerationPlant ) { this.cogenerationPlant = cogenerationPlant; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CogenerationPlant\"")
        private CogenerationPlant cogenerationPlant ;
         
        /**
         * A thermal generating unit may be a member of a combined cycle plant.
         */
        public CombinedCyclePlant getCombinedCyclePlant () { return combinedCyclePlant; }
        public void setCombinedCyclePlant ( CombinedCyclePlant combinedCyclePlant ) { this.combinedCyclePlant = combinedCyclePlant; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"CombinedCyclePlant\"")
        private CombinedCyclePlant combinedCyclePlant ;
         
        /**
         * A thermal generating unit may have a heat input curve.
         */
        public HeatInputCurve getHeatInputCurve () { return heatInputCurve; }
        public void setHeatInputCurve ( HeatInputCurve heatInputCurve ) { this.heatInputCurve = heatInputCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HeatInputCurve\"")
        private HeatInputCurve heatInputCurve ;
         
        /**
         * A thermal generating unit may have a heat rate curve.
         */
        public HeatRateCurve getHeatRateCurve () { return heatRateCurve; }
        public void setHeatRateCurve ( HeatRateCurve heatRateCurve ) { this.heatRateCurve = heatRateCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"HeatRateCurve\"")
        private HeatRateCurve heatRateCurve ;
         
        /**
         * A thermal generating unit may have an incremental heat rate curve.
         */
        public IncrementalHeatRateCurve getIncrementalHeatRateCurve () { return incrementalHeatRateCurve; }
        public void setIncrementalHeatRateCurve ( IncrementalHeatRateCurve incrementalHeatRateCurve ) { this.incrementalHeatRateCurve = incrementalHeatRateCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"IncrementalHeatRateCurve\"")
        private IncrementalHeatRateCurve incrementalHeatRateCurve ;
         
        /**
         * A thermal generating unit may have a shutdown curve.
         */
        public ShutdownCurve getShutdownCurve () { return shutdownCurve; }
        public void setShutdownCurve ( ShutdownCurve shutdownCurve ) { this.shutdownCurve = shutdownCurve; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"ShutdownCurve\"")
        private ShutdownCurve shutdownCurve ;
         
        /**
         * A thermal generating unit may have a startup model.
         */
        public StartupModel getStartupModel () { return startupModel; }
        public void setStartupModel ( StartupModel startupModel ) { this.startupModel = startupModel; }
        @ManyToOne(fetch=FetchType.LAZY)
        @JoinColumn(name="\"StartupModel\"")
        private StartupModel startupModel ;
         
    }
     
    /**
     * Kind of wind generating unit.
     */
    @Entity
    @Table(name="\"WindGenUnitKind\"")
    public static class WindGenUnitKind
    {
        public String getName () { return name; }
        public void setName ( String name ) { this.name = name; }
        @Id
        @Column(name="\"name\"")
        private String name ;
         
    };
    /**
     * A wind driven generating unit, connected to the grid by means of a rotating
     * machine. May be used to represent a single turbine or an aggregation.
     */
    @Entity
    @Table(name="\"WindGeneratingUnit\"")
    @PrimaryKeyJoinColumn(name="\"mRID\"")
    public static class WindGeneratingUnit extends GeneratingUnit
    {
        /**
         * The kind of wind generating unit.
         */
        public String getWindGenUnitType () { return windGenUnitType; }
        public void setWindGenUnitType ( String windGenUnitType ) { this.windGenUnitType = windGenUnitType; }
        @Basic()
        @Column(name="\"windGenUnitType\"")
        private String windGenUnitType ;
         
    }
     
    public static final Class[] allClasses = new Class[]
    {
        AirCompressor.class,
        BatteryStateKind.class,
        BatteryStateKind1.class,
        BatteryUnit.class,
        BatteryUnit1.class,
        CAESPlant.class,
        CAESPlant1.class,
        CogenerationPlant.class,
        CombinedCyclePlant.class,
        CombustionTurbine.class,
        EmissionAccount.class,
        EmissionCurve.class,
        EmissionType.class,
        EmissionType1.class,
        EmissionValueSource.class,
        EmissionValueSource1.class,
        FossilFuel.class,
        FuelAllocationSchedule.class,
        FuelType.class,
        FuelType1.class,
        GenUnitOpCostCurve.class,
        GenUnitOpSchedule.class,
        GeneratingUnit.class,
        GeneratingUnit1.class,
        GeneratorControlMode.class,
        GeneratorControlMode1.class,
        GeneratorControlSource.class,
        GeneratorControlSource1.class,
        GrossToNetActivePowerCurve.class,
        HeatInputCurve.class,
        HeatRateCurve.class,
        HydroEnergyConversionKind.class,
        HydroGeneratingEfficiencyCurve.class,
        HydroGeneratingUnit.class,
        HydroGeneratingUnit1.class,
        HydroPlantStorageKind.class,
        HydroPowerPlant.class,
        HydroPowerPlant1.class,
        HydroPump.class,
        HydroPumpOpSchedule.class,
        HydroPumpOpSchedule1.class,
        HydroTurbineKind.class,
        IncrementalHeatRateCurve.class,
        InflowForecast.class,
        LevelVsVolumeCurve.class,
        NuclearGeneratingUnit.class,
        PenstockLossCurve.class,
        PenstockLossCurve1.class,
        PhotoVoltaicUnit.class,
        PowerElectronicsConnection.class,
        PowerElectronicsUnit.class,
        PowerElectronicsWindUnit.class,
        Reservoir.class,
        Reservoir1.class,
        RotatingMachine.class,
        ShutdownCurve.class,
        SolarGeneratingUnit.class,
        StartIgnFuelCurve.class,
        StartMainFuelCurve.class,
        StartRampCurve.class,
        StartupModel.class,
        StartupModel1.class,
        SteamSendoutSchedule.class,
        SteamSendoutSchedule1.class,
        TailbayLossCurve.class,
        TargetLevelSchedule.class,
        TargetLevelSchedule1.class,
        ThermalGeneratingUnit.class,
        ThermalGeneratingUnit1.class,
        WindGenUnitKind.class,
        WindGeneratingUnit.class
    };
}
